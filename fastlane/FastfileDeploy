default_platform(:ios)

platform :ios do

  lane :release_dev do
    deploy(config: ENV["APP_CONF_DEVELOP"])
  end

  lane :release_anytype do
    deploy(config: ENV["APP_CONF_RELEASE_ANYTYPE"])
  end

  # Private lanes

  private_lane :deploy do |options| 
    
    ensure_git_status_clean
    
    config_settings = {
      ENV["APP_CONF_DEVELOP"] => {
        tag_prefix: "dev",
        add_badge: true,
        app_info: "Debug",
        bundle_id: "io.anytype.app.dev"
      },
      ENV["APP_CONF_RELEASE_ANYTYPE"] => {
        tag_prefix: "release-anytype",
        add_badge: false,
        app_info: "Release Anytype",
        bundle_id: "io.anytype.app"
      }
    }

    setup_ci
    match(readonly: true)

    set_api_key

    config = options[:config]
    
    settings = config_settings[config]

    puts "Start Build: #{config}"
    
    xcodeproj = ENV["APP_PROJECT"]
    version = get_version_number(xcodeproj: xcodeproj, target: ENV["APP_TARGET"])
    # Release build should be started from last dev build
    build_number_dev = latest_testflight_build_number(app_identifier: ENV["APP_ID_DEVELOP"], version: version, initial_build_number: 0)
    build_number = latest_testflight_build_number(version: version, initial_build_number: build_number_dev) + 1
    
    # Find available build number by checking git tags
    prefix = settings[:tag_prefix]
    max_attempts = 100
    current_attempt = 0
    
    while current_attempt < max_attempts do
      tag_name = "#{prefix}/#{version}/#{build_number}"
      tag_exists = sh("git tag -l #{tag_name}").strip != ""
      
      if tag_exists
        puts "Tag #{tag_name} already exists, trying next build number"
        build_number += 1
        current_attempt += 1
      else
        puts "Found available build number: #{build_number}"
        break
      end
    end
    
    if current_attempt >= max_attempts
      UI.user_error!("Could not find available build number after #{max_attempts} attempts")
    end
    
    if settings[:add_badge]
      add_badge(
        shield: "#{version}-#{build_number}-blue",
        no_badge: true
      )
    end

    increment_build_number(build_number: build_number, xcodeproj: xcodeproj, skip_info_plist: true)
    
    set_all_env_to_info_plist
    
    build_app(
      scheme: ENV["APP_TARGET"], 
      configuration: config,
      include_symbols: true,
      use_system_scm: true,
      archive_path: "./build/archive",
      output_directory: "./build/result",
      xcargs: ENV['BUILD_OPTIONS']
    )

    # Reset icon/info.plist changes
    reset_git_repo(skip_clean: true)
  
    tag_name = "#{prefix}/#{version}/#{build_number}"

    add_git_tag(tag: tag_name, force: true)
    sh("git push origin refs/tags/#{tag_name} --no-verify --force")
  
    appInfo = settings[:app_info]

    # Determine the previous tag to use for diff generation in Linear comments
    # This ensures hotfix releases (e.g., 0.41.1) correctly diff against the last build
    # of the previous version (0.41.0/27) instead of finding an old tag from a different branch

    # Helper lambda to find the last tag from the previous version
    find_previous_version_tag = lambda do
      version_parts = version.split('.')
      major_minor = "#{version_parts[0]}.#{version_parts[1]}"
      current_patch = version_parts[2].to_i

      # Get all tags for the current major.minor (e.g., all 0.41.x tags), sorted by version
      all_version_tags = sh("git tag -l '#{prefix}/#{major_minor}.*/*' | sort -V").split("\n")

      # Find tags for versions less than current patch, take the last one
      previous_version_tags = all_version_tags.select do |t|
        tag_patch = t.match(/#{Regexp.escape(prefix)}\/#{Regexp.escape(major_minor)}\.(\d+)\//)
        tag_patch && tag_patch[1].to_i < current_patch
      end

      previous_version_tags.last || tag_name
    end

    if build_number.to_i > 1
      # For incremental builds (e.g., 0.41.0/26 -> 0.41.0/27), try to use the previous build number
      candidate_tag = "#{prefix}/#{version}/#{build_number.to_i - 1}"

      # Check if this tag actually exists (build numbers can skip due to TestFlight)
      if sh("git tag -l #{candidate_tag}").strip != ""
        old_tag_name = candidate_tag
      else
        # Previous build tag doesn't exist - fall back to finding last tag from previous version
        puts "⚠️  Previous build tag #{candidate_tag} not found, falling back to previous version"
        old_tag_name = find_previous_version_tag.call
      end
    else
      # For the first build of a new version (e.g., 0.41.1/1), find the last tag of the previous patch version
      old_tag_name = find_previous_version_tag.call
    end

    # Check if we should add Linear comments
    # For release patch builds: Skip if (1) old_tag is the same as new tag (first release)
    #                                    (2) both tags point to the same commit (retried build)
    # For release minor/major builds: Always add comments (skip only if first release)
    # For dev/nightly builds: Always add comments (skip only if first release)
    is_release_build = prefix == "release-anytype"

    # Detect if this is a patch release (same major.minor, different patch)
    is_patch_release = false
    if is_release_build && old_tag_name != tag_name
      # Extract versions from both tags
      old_version = old_tag_name.match(/#{Regexp.escape(prefix)}\/([^\/]+)\//)
      new_version = tag_name.match(/#{Regexp.escape(prefix)}\/([^\/]+)\//)

      if old_version && new_version
        old_parts = old_version[1].split('.')
        new_parts = new_version[1].split('.')

        # Check if major.minor are the same
        if old_parts.length >= 2 && new_parts.length >= 2 &&
           old_parts[0] == new_parts[0] && old_parts[1] == new_parts[1]
          is_patch_release = true
        end
      end
    end

    if old_tag_name == tag_name
      puts "⏭️  Skipping Linear comments: First release, no previous version to compare"
    elsif is_release_build && is_patch_release
      # For release patch builds: check if commits match to avoid duplicates on retried builds
      old_commit = sh("git rev-parse #{old_tag_name}^{commit} 2>/dev/null || echo ''").strip
      new_commit = sh("git rev-parse #{tag_name}^{commit}").strip

      if old_commit.empty?
        puts "⚠️  Warning: Could not find commit for #{old_tag_name}, skipping Linear comments"
      elsif old_commit == new_commit
        puts "⏭️  Skipping Linear comments: #{old_tag_name} and #{tag_name} point to the same commit (#{old_commit[0..7]})"
      else
        add_linear_comment(
          from_tag: old_tag_name,
          to_tag: tag_name,
          comment: "Implemented in **#{appInfo}** `#{version}(#{build_number})`. This comment was created automatically."
        )
      end
    else
      # For release minor/major and dev/nightly builds: always add comments without commit comparison
      add_linear_comment(
        from_tag: old_tag_name,
        to_tag: tag_name,
        comment: "Implemented in **#{appInfo}** `#{version}(#{build_number})`. This comment was created automatically."
      )
    end
  
    bundle_id = settings[:bundle_id]
    ENV["DELIVER_ALTOOL_ADDITIONAL_UPLOAD_PARAMETERS"] = "--apple-id #{bundle_id} --use-old-altool"

    upload_to_testflight(skip_waiting_for_build_processing: true)

    github_message = "Anytype #{appInfo} Version: **#{version}(#{build_number})** :gem::gem::gem:"
    sh("echo FASTLANE_GITHUB_SUMMARY='#{github_message}' >> $GITHUB_ENV")
    
    slack_message = "Anytype #{appInfo} Version: *#{version}(#{build_number})*"
    sh("echo FASTLANE_SLACK_SUMMARY='#{slack_message}' >> $GITHUB_ENV")

    upload_dsyms_to_sentry

  end
  
  private_lane :upload_dsyms_to_sentry do |options|

    sentry_upload_dif(
      url: 'https://sentry.anytype.io',
      auth_token: ENV["SENTRY_AUTH_TOKEN"],
      org_slug: 'anytype',
      project_slug: 'ios',
      path: "./build/result"
    )
  end

end
