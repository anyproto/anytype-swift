// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pkg/lib/pb/model/protos/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

extension Anytype_Model_Block.Content.Dataview {
    public struct Filter: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        /// looks not applicable?
        public var `operator`: Anytype_Model_Block.Content.Dataview.Filter.Operator = .no

        public var relationKey: String = String()

        public var relationProperty: String = String()

        public var condition: Anytype_Model_Block.Content.Dataview.Filter.Condition = .none

        public var value: SwiftProtobuf.Google_Protobuf_Value {
          get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
          set {_value = newValue}
        }
        /// Returns true if `value` has been explicitly set.
        public var hasValue: Bool {return self._value != nil}
        /// Clears the value of `value`. Subsequent reads from it will return its default value.
        public mutating func clearValue() {self._value = nil}

        public var quickOption: Anytype_Model_Block.Content.Dataview.Filter.QuickOption = .exactDate

        public var format: Anytype_Model_RelationFormat = .longtext

        public var includeTime: Bool = false

        public var nestedFilters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
          public typealias RawValue = Int
          case no // = 0
          case or // = 1
          case and // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .no
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .no
            case 1: self = .or
            case 2: self = .and
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .no: return 0
            case .or: return 1
            case .and: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.Operator] = [
            .no,
            .or,
            .and,
          ]

        }

        public enum Condition: SwiftProtobuf.Enum, Swift.CaseIterable {
          public typealias RawValue = Int
          case none // = 0
          case equal // = 1
          case notEqual // = 2
          case greater // = 3
          case less // = 4
          case greaterOrEqual // = 5
          case lessOrEqual // = 6
          case like // = 7
          case notLike // = 8

          /// "at least one value(from the provided list) is IN"
          case `in` // = 9

          /// "none of provided values are IN"
          case notIn // = 10
          case empty // = 11
          case notEmpty // = 12
          case allIn // = 13
          case notAllIn // = 14
          case exactIn // = 15
          case notExactIn // = 16
          case exists // = 17
          case UNRECOGNIZED(Int)

          public init() {
            self = .none
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .equal
            case 2: self = .notEqual
            case 3: self = .greater
            case 4: self = .less
            case 5: self = .greaterOrEqual
            case 6: self = .lessOrEqual
            case 7: self = .like
            case 8: self = .notLike
            case 9: self = .in
            case 10: self = .notIn
            case 11: self = .empty
            case 12: self = .notEmpty
            case 13: self = .allIn
            case 14: self = .notAllIn
            case 15: self = .exactIn
            case 16: self = .notExactIn
            case 17: self = .exists
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .none: return 0
            case .equal: return 1
            case .notEqual: return 2
            case .greater: return 3
            case .less: return 4
            case .greaterOrEqual: return 5
            case .lessOrEqual: return 6
            case .like: return 7
            case .notLike: return 8
            case .in: return 9
            case .notIn: return 10
            case .empty: return 11
            case .notEmpty: return 12
            case .allIn: return 13
            case .notAllIn: return 14
            case .exactIn: return 15
            case .notExactIn: return 16
            case .exists: return 17
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.Condition] = [
            .none,
            .equal,
            .notEqual,
            .greater,
            .less,
            .greaterOrEqual,
            .lessOrEqual,
            .like,
            .notLike,
            .in,
            .notIn,
            .empty,
            .notEmpty,
            .allIn,
            .notAllIn,
            .exactIn,
            .notExactIn,
            .exists,
          ]

        }

        public enum QuickOption: SwiftProtobuf.Enum, Swift.CaseIterable {
          public typealias RawValue = Int
          case exactDate // = 0
          case yesterday // = 1
          case today // = 2
          case tomorrow // = 3
          case lastWeek // = 4
          case currentWeek // = 5
          case nextWeek // = 6
          case lastMonth // = 7
          case currentMonth // = 8
          case nextMonth // = 9
          case numberOfDaysAgo // = 10
          case numberOfDaysNow // = 11
          case lastYear // = 12
          case currentYear // = 13
          case nextYear // = 14
          case UNRECOGNIZED(Int)

          public init() {
            self = .exactDate
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .exactDate
            case 1: self = .yesterday
            case 2: self = .today
            case 3: self = .tomorrow
            case 4: self = .lastWeek
            case 5: self = .currentWeek
            case 6: self = .nextWeek
            case 7: self = .lastMonth
            case 8: self = .currentMonth
            case 9: self = .nextMonth
            case 10: self = .numberOfDaysAgo
            case 11: self = .numberOfDaysNow
            case 12: self = .lastYear
            case 13: self = .currentYear
            case 14: self = .nextYear
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .exactDate: return 0
            case .yesterday: return 1
            case .today: return 2
            case .tomorrow: return 3
            case .lastWeek: return 4
            case .currentWeek: return 5
            case .nextWeek: return 6
            case .lastMonth: return 7
            case .currentMonth: return 8
            case .nextMonth: return 9
            case .numberOfDaysAgo: return 10
            case .numberOfDaysNow: return 11
            case .lastYear: return 12
            case .currentYear: return 13
            case .nextYear: return 14
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.QuickOption] = [
            .exactDate,
            .yesterday,
            .today,
            .tomorrow,
            .lastWeek,
            .currentWeek,
            .nextWeek,
            .lastMonth,
            .currentMonth,
            .nextMonth,
            .numberOfDaysAgo,
            .numberOfDaysNow,
            .lastYear,
            .currentYear,
            .nextYear,
          ]

        }

        public init() {}

        fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
      }    
}

extension Anytype_Model_Block.Content.Dataview.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "operator"),
    2: .same(proto: "RelationKey"),
    5: .same(proto: "relationProperty"),
    3: .same(proto: "condition"),
    4: .same(proto: "value"),
    6: .same(proto: "quickOption"),
    7: .same(proto: "format"),
    8: .same(proto: "includeTime"),
    10: .same(proto: "nestedFilters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.condition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.relationProperty) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quickOption) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.includeTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.nestedFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.`operator` != .no {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    if self.condition != .none {
      try visitor.visitSingularEnumField(value: self.condition, fieldNumber: 3)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.relationProperty.isEmpty {
      try visitor.visitSingularStringField(value: self.relationProperty, fieldNumber: 5)
    }
    if self.quickOption != .exactDate {
      try visitor.visitSingularEnumField(value: self.quickOption, fieldNumber: 6)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 7)
    }
    if self.includeTime != false {
      try visitor.visitSingularBoolField(value: self.includeTime, fieldNumber: 8)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 9)
    }
    if !self.nestedFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nestedFilters, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Filter, rhs: Anytype_Model_Block.Content.Dataview.Filter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.relationProperty != rhs.relationProperty {return false}
    if lhs.condition != rhs.condition {return false}
    if lhs._value != rhs._value {return false}
    if lhs.quickOption != rhs.quickOption {return false}
    if lhs.format != rhs.format {return false}
    if lhs.includeTime != rhs.includeTime {return false}
    if lhs.nestedFilters != rhs.nestedFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Filter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "No"),
    1: .same(proto: "Or"),
    2: .same(proto: "And"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Condition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Equal"),
    2: .same(proto: "NotEqual"),
    3: .same(proto: "Greater"),
    4: .same(proto: "Less"),
    5: .same(proto: "GreaterOrEqual"),
    6: .same(proto: "LessOrEqual"),
    7: .same(proto: "Like"),
    8: .same(proto: "NotLike"),
    9: .same(proto: "In"),
    10: .same(proto: "NotIn"),
    11: .same(proto: "Empty"),
    12: .same(proto: "NotEmpty"),
    13: .same(proto: "AllIn"),
    14: .same(proto: "NotAllIn"),
    15: .same(proto: "ExactIn"),
    16: .same(proto: "NotExactIn"),
    17: .same(proto: "Exists"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ExactDate"),
    1: .same(proto: "Yesterday"),
    2: .same(proto: "Today"),
    3: .same(proto: "Tomorrow"),
    4: .same(proto: "LastWeek"),
    5: .same(proto: "CurrentWeek"),
    6: .same(proto: "NextWeek"),
    7: .same(proto: "LastMonth"),
    8: .same(proto: "CurrentMonth"),
    9: .same(proto: "NextMonth"),
    10: .same(proto: "NumberOfDaysAgo"),
    11: .same(proto: "NumberOfDaysNow"),
    12: .same(proto: "LastYear"),
    13: .same(proto: "CurrentYear"),
    14: .same(proto: "NextYear"),
  ]
}

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype.model"
