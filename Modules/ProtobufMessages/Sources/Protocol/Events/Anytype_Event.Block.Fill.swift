// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pb/protos/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

extension Anytype_Event.Block {
    public struct Fill: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Details: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct DatabaseRecords: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var records: [SwiftProtobuf.Google_Protobuf_Struct] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Fields: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var fields: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_fields = newValue}
        }
        /// Returns true if `fields` has been explicitly set.
        public var hasFields: Bool {return self._fields != nil}
        /// Clears the value of `fields`. Subsequent reads from it will return its default value.
        public mutating func clearFields() {self._fields = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct ChildrenIds: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var childrenIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Restrictions: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var restrictions: Anytype_Model_Block.Restrictions {
          get {return _restrictions ?? Anytype_Model_Block.Restrictions()}
          set {_restrictions = newValue}
        }
        /// Returns true if `restrictions` has been explicitly set.
        public var hasRestrictions: Bool {return self._restrictions != nil}
        /// Clears the value of `restrictions`. Subsequent reads from it will return its default value.
        public mutating func clearRestrictions() {self._restrictions = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _restrictions: Anytype_Model_Block.Restrictions? = nil
      }

      public struct BackgroundColor: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var backgroundColor: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Align: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var align: Anytype_Model_Block.Align = .left

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Text: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var text: Anytype_Event.Block.Fill.Text.Text {
          get {return _text ?? Anytype_Event.Block.Fill.Text.Text()}
          set {_text = newValue}
        }
        /// Returns true if `text` has been explicitly set.
        public var hasText: Bool {return self._text != nil}
        /// Clears the value of `text`. Subsequent reads from it will return its default value.
        public mutating func clearText() {self._text = nil}

        public var style: Anytype_Event.Block.Fill.Text.Style {
          get {return _style ?? Anytype_Event.Block.Fill.Text.Style()}
          set {_style = newValue}
        }
        /// Returns true if `style` has been explicitly set.
        public var hasStyle: Bool {return self._style != nil}
        /// Clears the value of `style`. Subsequent reads from it will return its default value.
        public mutating func clearStyle() {self._style = nil}

        public var marks: Anytype_Event.Block.Fill.Text.Marks {
          get {return _marks ?? Anytype_Event.Block.Fill.Text.Marks()}
          set {_marks = newValue}
        }
        /// Returns true if `marks` has been explicitly set.
        public var hasMarks: Bool {return self._marks != nil}
        /// Clears the value of `marks`. Subsequent reads from it will return its default value.
        public mutating func clearMarks() {self._marks = nil}

        public var checked: Anytype_Event.Block.Fill.Text.Checked {
          get {return _checked ?? Anytype_Event.Block.Fill.Text.Checked()}
          set {_checked = newValue}
        }
        /// Returns true if `checked` has been explicitly set.
        public var hasChecked: Bool {return self._checked != nil}
        /// Clears the value of `checked`. Subsequent reads from it will return its default value.
        public mutating func clearChecked() {self._checked = nil}

        public var color: Anytype_Event.Block.Fill.Text.Color {
          get {return _color ?? Anytype_Event.Block.Fill.Text.Color()}
          set {_color = newValue}
        }
        /// Returns true if `color` has been explicitly set.
        public var hasColor: Bool {return self._color != nil}
        /// Clears the value of `color`. Subsequent reads from it will return its default value.
        public mutating func clearColor() {self._color = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Text: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Style: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.Text.Style = .paragraph

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Marks: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.Text.Marks {
            get {return _value ?? Anytype_Model_Block.Content.Text.Marks()}
            set {_value = newValue}
          }
          /// Returns true if `value` has been explicitly set.
          public var hasValue: Bool {return self._value != nil}
          /// Clears the value of `value`. Subsequent reads from it will return its default value.
          public mutating func clearValue() {self._value = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _value: Anytype_Model_Block.Content.Text.Marks? = nil
        }

        public struct Checked: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Bool = false

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Color: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _text: Anytype_Event.Block.Fill.Text.Text? = nil
        fileprivate var _style: Anytype_Event.Block.Fill.Text.Style? = nil
        fileprivate var _marks: Anytype_Event.Block.Fill.Text.Marks? = nil
        fileprivate var _checked: Anytype_Event.Block.Fill.Text.Checked? = nil
        fileprivate var _color: Anytype_Event.Block.Fill.Text.Color? = nil
      }

      public struct Div: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var style: Anytype_Event.Block.Fill.Div.Style {
          get {return _style ?? Anytype_Event.Block.Fill.Div.Style()}
          set {_style = newValue}
        }
        /// Returns true if `style` has been explicitly set.
        public var hasStyle: Bool {return self._style != nil}
        /// Clears the value of `style`. Subsequent reads from it will return its default value.
        public mutating func clearStyle() {self._style = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Style: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.Div.Style = .line

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _style: Anytype_Event.Block.Fill.Div.Style? = nil
      }

      public struct File: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var type: Anytype_Event.Block.Fill.File.TypeMessage {
          get {return _type ?? Anytype_Event.Block.Fill.File.TypeMessage()}
          set {_type = newValue}
        }
        /// Returns true if `type` has been explicitly set.
        public var hasType: Bool {return self._type != nil}
        /// Clears the value of `type`. Subsequent reads from it will return its default value.
        public mutating func clearType() {self._type = nil}

        public var state: Anytype_Event.Block.Fill.File.State {
          get {return _state ?? Anytype_Event.Block.Fill.File.State()}
          set {_state = newValue}
        }
        /// Returns true if `state` has been explicitly set.
        public var hasState: Bool {return self._state != nil}
        /// Clears the value of `state`. Subsequent reads from it will return its default value.
        public mutating func clearState() {self._state = nil}

        public var mime: Anytype_Event.Block.Fill.File.Mime {
          get {return _mime ?? Anytype_Event.Block.Fill.File.Mime()}
          set {_mime = newValue}
        }
        /// Returns true if `mime` has been explicitly set.
        public var hasMime: Bool {return self._mime != nil}
        /// Clears the value of `mime`. Subsequent reads from it will return its default value.
        public mutating func clearMime() {self._mime = nil}

        public var hash: Anytype_Event.Block.Fill.File.Hash {
          get {return _hash ?? Anytype_Event.Block.Fill.File.Hash()}
          set {_hash = newValue}
        }
        /// Returns true if `hash` has been explicitly set.
        public var hasHash: Bool {return self._hash != nil}
        /// Clears the value of `hash`. Subsequent reads from it will return its default value.
        public mutating func clearHash() {self._hash = nil}

        public var name: Anytype_Event.Block.Fill.File.Name {
          get {return _name ?? Anytype_Event.Block.Fill.File.Name()}
          set {_name = newValue}
        }
        /// Returns true if `name` has been explicitly set.
        public var hasName: Bool {return self._name != nil}
        /// Clears the value of `name`. Subsequent reads from it will return its default value.
        public mutating func clearName() {self._name = nil}

        public var size: Anytype_Event.Block.Fill.File.Size {
          get {return _size ?? Anytype_Event.Block.Fill.File.Size()}
          set {_size = newValue}
        }
        /// Returns true if `size` has been explicitly set.
        public var hasSize: Bool {return self._size != nil}
        /// Clears the value of `size`. Subsequent reads from it will return its default value.
        public mutating func clearSize() {self._size = nil}

        public var style: Anytype_Event.Block.Fill.File.Style {
          get {return _style ?? Anytype_Event.Block.Fill.File.Style()}
          set {_style = newValue}
        }
        /// Returns true if `style` has been explicitly set.
        public var hasStyle: Bool {return self._style != nil}
        /// Clears the value of `style`. Subsequent reads from it will return its default value.
        public mutating func clearStyle() {self._style = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Name: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Width: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Int32 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct State: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.File.State = .empty

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct TypeMessage: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.File.TypeEnum = .none

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Style: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.File.Style = .auto

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Hash: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Mime: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Size: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Int64 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _type: Anytype_Event.Block.Fill.File.TypeMessage? = nil
        fileprivate var _state: Anytype_Event.Block.Fill.File.State? = nil
        fileprivate var _mime: Anytype_Event.Block.Fill.File.Mime? = nil
        fileprivate var _hash: Anytype_Event.Block.Fill.File.Hash? = nil
        fileprivate var _name: Anytype_Event.Block.Fill.File.Name? = nil
        fileprivate var _size: Anytype_Event.Block.Fill.File.Size? = nil
        fileprivate var _style: Anytype_Event.Block.Fill.File.Style? = nil
      }

      public struct Link: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var targetBlockID: Anytype_Event.Block.Fill.Link.TargetBlockId {
          get {return _targetBlockID ?? Anytype_Event.Block.Fill.Link.TargetBlockId()}
          set {_targetBlockID = newValue}
        }
        /// Returns true if `targetBlockID` has been explicitly set.
        public var hasTargetBlockID: Bool {return self._targetBlockID != nil}
        /// Clears the value of `targetBlockID`. Subsequent reads from it will return its default value.
        public mutating func clearTargetBlockID() {self._targetBlockID = nil}

        public var style: Anytype_Event.Block.Fill.Link.Style {
          get {return _style ?? Anytype_Event.Block.Fill.Link.Style()}
          set {_style = newValue}
        }
        /// Returns true if `style` has been explicitly set.
        public var hasStyle: Bool {return self._style != nil}
        /// Clears the value of `style`. Subsequent reads from it will return its default value.
        public mutating func clearStyle() {self._style = nil}

        public var fields: Anytype_Event.Block.Fill.Link.Fields {
          get {return _fields ?? Anytype_Event.Block.Fill.Link.Fields()}
          set {_fields = newValue}
        }
        /// Returns true if `fields` has been explicitly set.
        public var hasFields: Bool {return self._fields != nil}
        /// Clears the value of `fields`. Subsequent reads from it will return its default value.
        public mutating func clearFields() {self._fields = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct TargetBlockId: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Style: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_Block.Content.Link.Style = .page

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Fields: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: SwiftProtobuf.Google_Protobuf_Struct {
            get {return _value ?? SwiftProtobuf.Google_Protobuf_Struct()}
            set {_value = newValue}
          }
          /// Returns true if `value` has been explicitly set.
          public var hasValue: Bool {return self._value != nil}
          /// Clears the value of `value`. Subsequent reads from it will return its default value.
          public mutating func clearValue() {self._value = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _value: SwiftProtobuf.Google_Protobuf_Struct? = nil
        }

        public init() {}

        fileprivate var _targetBlockID: Anytype_Event.Block.Fill.Link.TargetBlockId? = nil
        fileprivate var _style: Anytype_Event.Block.Fill.Link.Style? = nil
        fileprivate var _fields: Anytype_Event.Block.Fill.Link.Fields? = nil
      }

      public struct Bookmark: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var url: Anytype_Event.Block.Fill.Bookmark.Url {
          get {return _url ?? Anytype_Event.Block.Fill.Bookmark.Url()}
          set {_url = newValue}
        }
        /// Returns true if `url` has been explicitly set.
        public var hasURL: Bool {return self._url != nil}
        /// Clears the value of `url`. Subsequent reads from it will return its default value.
        public mutating func clearURL() {self._url = nil}

        public var title: Anytype_Event.Block.Fill.Bookmark.Title {
          get {return _title ?? Anytype_Event.Block.Fill.Bookmark.Title()}
          set {_title = newValue}
        }
        /// Returns true if `title` has been explicitly set.
        public var hasTitle: Bool {return self._title != nil}
        /// Clears the value of `title`. Subsequent reads from it will return its default value.
        public mutating func clearTitle() {self._title = nil}

        public var description_p: Anytype_Event.Block.Fill.Bookmark.Description {
          get {return _description_p ?? Anytype_Event.Block.Fill.Bookmark.Description()}
          set {_description_p = newValue}
        }
        /// Returns true if `description_p` has been explicitly set.
        public var hasDescription_p: Bool {return self._description_p != nil}
        /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
        public mutating func clearDescription_p() {self._description_p = nil}

        public var imageHash: Anytype_Event.Block.Fill.Bookmark.ImageHash {
          get {return _imageHash ?? Anytype_Event.Block.Fill.Bookmark.ImageHash()}
          set {_imageHash = newValue}
        }
        /// Returns true if `imageHash` has been explicitly set.
        public var hasImageHash: Bool {return self._imageHash != nil}
        /// Clears the value of `imageHash`. Subsequent reads from it will return its default value.
        public mutating func clearImageHash() {self._imageHash = nil}

        public var faviconHash: Anytype_Event.Block.Fill.Bookmark.FaviconHash {
          get {return _faviconHash ?? Anytype_Event.Block.Fill.Bookmark.FaviconHash()}
          set {_faviconHash = newValue}
        }
        /// Returns true if `faviconHash` has been explicitly set.
        public var hasFaviconHash: Bool {return self._faviconHash != nil}
        /// Clears the value of `faviconHash`. Subsequent reads from it will return its default value.
        public mutating func clearFaviconHash() {self._faviconHash = nil}

        public var type: Anytype_Event.Block.Fill.Bookmark.TypeMessage {
          get {return _type ?? Anytype_Event.Block.Fill.Bookmark.TypeMessage()}
          set {_type = newValue}
        }
        /// Returns true if `type` has been explicitly set.
        public var hasType: Bool {return self._type != nil}
        /// Clears the value of `type`. Subsequent reads from it will return its default value.
        public mutating func clearType() {self._type = nil}

        public var targetObjectID: Anytype_Event.Block.Fill.Bookmark.TargetObjectId {
          get {return _targetObjectID ?? Anytype_Event.Block.Fill.Bookmark.TargetObjectId()}
          set {_targetObjectID = newValue}
        }
        /// Returns true if `targetObjectID` has been explicitly set.
        public var hasTargetObjectID: Bool {return self._targetObjectID != nil}
        /// Clears the value of `targetObjectID`. Subsequent reads from it will return its default value.
        public mutating func clearTargetObjectID() {self._targetObjectID = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Url: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Title: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Description: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct ImageHash: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct FaviconHash: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct TypeMessage: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: Anytype_Model_LinkPreview.TypeEnum = .unknown

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct TargetObjectId: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var value: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _url: Anytype_Event.Block.Fill.Bookmark.Url? = nil
        fileprivate var _title: Anytype_Event.Block.Fill.Bookmark.Title? = nil
        fileprivate var _description_p: Anytype_Event.Block.Fill.Bookmark.Description? = nil
        fileprivate var _imageHash: Anytype_Event.Block.Fill.Bookmark.ImageHash? = nil
        fileprivate var _faviconHash: Anytype_Event.Block.Fill.Bookmark.FaviconHash? = nil
        fileprivate var _type: Anytype_Event.Block.Fill.Bookmark.TypeMessage? = nil
        fileprivate var _targetObjectID: Anytype_Event.Block.Fill.Bookmark.TargetObjectId? = nil
      }

      public init() {}
    }    
}

extension Anytype_Event.Block.Fill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.protoMessageName + ".Fill"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill, rhs: Anytype_Event.Block.Fill) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Details: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Details"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Details, rhs: Anytype_Event.Block.Fill.Details) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.DatabaseRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".DatabaseRecords"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}records\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.DatabaseRecords, rhs: Anytype_Event.Block.Fill.DatabaseRecords) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Fields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Fields"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}fields\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Fields, rhs: Anytype_Event.Block.Fill.Fields) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.ChildrenIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".ChildrenIds"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}childrenIds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.childrenIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.childrenIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.childrenIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.ChildrenIds, rhs: Anytype_Event.Block.Fill.ChildrenIds) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.childrenIds != rhs.childrenIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Restrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Restrictions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}restrictions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._restrictions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._restrictions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Restrictions, rhs: Anytype_Event.Block.Fill.Restrictions) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._restrictions != rhs._restrictions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.BackgroundColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".BackgroundColor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}backgroundColor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backgroundColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.backgroundColor.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundColor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.BackgroundColor, rhs: Anytype_Event.Block.Fill.BackgroundColor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.backgroundColor != rhs.backgroundColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Align: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Align"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}align\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Align, rhs: Anytype_Event.Block.Fill.Align) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.align != rhs.align {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}text\0\u{1}style\0\u{1}marks\0\u{1}checked\0\u{1}color\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._marks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checked) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._marks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._checked {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text, rhs: Anytype_Event.Block.Fill.Text) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._text != rhs._text {return false}
    if lhs._style != rhs._style {return false}
    if lhs._marks != rhs._marks {return false}
    if lhs._checked != rhs._checked {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Text.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text.Text, rhs: Anytype_Event.Block.Fill.Text.Text) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Text.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .paragraph {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text.Style, rhs: Anytype_Event.Block.Fill.Text.Style) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text.Marks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Text.protoMessageName + ".Marks"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text.Marks, rhs: Anytype_Event.Block.Fill.Text.Marks) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text.Checked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Text.protoMessageName + ".Checked"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text.Checked, rhs: Anytype_Event.Block.Fill.Text.Checked) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Text.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Text.protoMessageName + ".Color"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Text.Color, rhs: Anytype_Event.Block.Fill.Text.Color) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Div: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Div"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Div, rhs: Anytype_Event.Block.Fill.Div) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Div.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Div.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .line {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Div.Style, rhs: Anytype_Event.Block.Fill.Div.Style) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".File"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}type\0\u{1}state\0\u{1}mime\0\u{1}hash\0\u{1}name\0\u{1}size\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._mime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File, rhs: Anytype_Event.Block.Fill.File) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._state != rhs._state {return false}
    if lhs._mime != rhs._mime {return false}
    if lhs._hash != rhs._hash {return false}
    if lhs._name != rhs._name {return false}
    if lhs._size != rhs._size {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Name"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Name, rhs: Anytype_Event.Block.Fill.File.Name) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Width: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Width"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Width, rhs: Anytype_Event.Block.Fill.File.Width) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".State"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .empty {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.State, rhs: Anytype_Event.Block.Fill.File.State) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.TypeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Type"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .none {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.TypeMessage, rhs: Anytype_Event.Block.Fill.File.TypeMessage) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .auto {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Style, rhs: Anytype_Event.Block.Fill.File.Style) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Hash"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Hash, rhs: Anytype_Event.Block.Fill.File.Hash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Mime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Mime"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Mime, rhs: Anytype_Event.Block.Fill.File.Mime) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.File.Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.File.protoMessageName + ".Size"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.File.Size, rhs: Anytype_Event.Block.Fill.File.Size) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Link"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}targetBlockId\0\u{1}style\0\u{1}fields\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetBlockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._targetBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Link, rhs: Anytype_Event.Block.Fill.Link) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._targetBlockID != rhs._targetBlockID {return false}
    if lhs._style != rhs._style {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Link.TargetBlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Link.protoMessageName + ".TargetBlockId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Link.TargetBlockId, rhs: Anytype_Event.Block.Fill.Link.TargetBlockId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Link.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Link.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .page {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Link.Style, rhs: Anytype_Event.Block.Fill.Link.Style) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Link.Fields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Link.protoMessageName + ".Fields"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Link.Fields, rhs: Anytype_Event.Block.Fill.Link.Fields) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.protoMessageName + ".Bookmark"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}url\0\u{1}title\0\u{1}description\0\u{1}imageHash\0\u{1}faviconHash\0\u{1}type\0\u{1}targetObjectId\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._imageHash) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._faviconHash) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._targetObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._imageHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._faviconHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._targetObjectID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark, rhs: Anytype_Event.Block.Fill.Bookmark) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._imageHash != rhs._imageHash {return false}
    if lhs._faviconHash != rhs._faviconHash {return false}
    if lhs._type != rhs._type {return false}
    if lhs._targetObjectID != rhs._targetObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".Url"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.Url, rhs: Anytype_Event.Block.Fill.Bookmark.Url) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.Title: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".Title"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.Title, rhs: Anytype_Event.Block.Fill.Bookmark.Title) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.Description: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".Description"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.Description, rhs: Anytype_Event.Block.Fill.Bookmark.Description) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.ImageHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".ImageHash"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.ImageHash, rhs: Anytype_Event.Block.Fill.Bookmark.ImageHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.FaviconHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".FaviconHash"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.FaviconHash, rhs: Anytype_Event.Block.Fill.Bookmark.FaviconHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.TypeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".Type"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .unknown {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.TypeMessage, rhs: Anytype_Event.Block.Fill.Bookmark.TypeMessage) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Event.Block.Fill.Bookmark.TargetObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.Block.Fill.Bookmark.protoMessageName + ".TargetObjectId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Block.Fill.Bookmark.TargetObjectId, rhs: Anytype_Event.Block.Fill.Bookmark.TargetObjectId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype"
