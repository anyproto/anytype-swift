// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pb/protos/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

extension Anytype_Event {
    public struct Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var value: Anytype_Event.Message.OneOf_Value? = nil

    public var accountShow: Anytype_Event.Account.Show {
      get {
        if case .accountShow(let v)? = value {return v}
        return Anytype_Event.Account.Show()
      }
      set {value = .accountShow(newValue)}
    }

    public var accountDetails: Anytype_Event.Account.Details {
      get {
        if case .accountDetails(let v)? = value {return v}
        return Anytype_Event.Account.Details()
      }
      set {value = .accountDetails(newValue)}
    }

    public var accountConfigUpdate: Anytype_Event.Account.Config.Update {
      get {
        if case .accountConfigUpdate(let v)? = value {return v}
        return Anytype_Event.Account.Config.Update()
      }
      set {value = .accountConfigUpdate(newValue)}
    }

    public var accountUpdate: Anytype_Event.Account.Update {
      get {
        if case .accountUpdate(let v)? = value {return v}
        return Anytype_Event.Account.Update()
      }
      set {value = .accountUpdate(newValue)}
    }

    public var accountLinkChallenge: Anytype_Event.Account.LinkChallenge {
      get {
        if case .accountLinkChallenge(let v)? = value {return v}
        return Anytype_Event.Account.LinkChallenge()
      }
      set {value = .accountLinkChallenge(newValue)}
    }

    public var accountLinkChallengeHide: Anytype_Event.Account.LinkChallengeHide {
      get {
        if case .accountLinkChallengeHide(let v)? = value {return v}
        return Anytype_Event.Account.LinkChallengeHide()
      }
      set {value = .accountLinkChallengeHide(newValue)}
    }

    public var objectDetailsSet: Anytype_Event.Object.Details.Set {
      get {
        if case .objectDetailsSet(let v)? = value {return v}
        return Anytype_Event.Object.Details.Set()
      }
      set {value = .objectDetailsSet(newValue)}
    }

    public var objectDetailsAmend: Anytype_Event.Object.Details.Amend {
      get {
        if case .objectDetailsAmend(let v)? = value {return v}
        return Anytype_Event.Object.Details.Amend()
      }
      set {value = .objectDetailsAmend(newValue)}
    }

    public var objectDetailsUnset: Anytype_Event.Object.Details.Unset {
      get {
        if case .objectDetailsUnset(let v)? = value {return v}
        return Anytype_Event.Object.Details.Unset()
      }
      set {value = .objectDetailsUnset(newValue)}
    }

    public var objectRelationsAmend: Anytype_Event.Object.Relations.Amend {
      get {
        if case .objectRelationsAmend(let v)? = value {return v}
        return Anytype_Event.Object.Relations.Amend()
      }
      set {value = .objectRelationsAmend(newValue)}
    }

    public var objectRelationsRemove: Anytype_Event.Object.Relations.Remove {
      get {
        if case .objectRelationsRemove(let v)? = value {return v}
        return Anytype_Event.Object.Relations.Remove()
      }
      set {value = .objectRelationsRemove(newValue)}
    }

    public var objectRemove: Anytype_Event.Object.Remove {
      get {
        if case .objectRemove(let v)? = value {return v}
        return Anytype_Event.Object.Remove()
      }
      set {value = .objectRemove(newValue)}
    }

    public var objectClose: Anytype_Event.Object.Close {
      get {
        if case .objectClose(let v)? = value {return v}
        return Anytype_Event.Object.Close()
      }
      set {value = .objectClose(newValue)}
    }

    public var objectRestrictionsSet: Anytype_Event.Object.Restrictions.Set {
      get {
        if case .objectRestrictionsSet(let v)? = value {return v}
        return Anytype_Event.Object.Restrictions.Set()
      }
      set {value = .objectRestrictionsSet(newValue)}
    }

    public var subscriptionAdd: Anytype_Event.Object.Subscription.Add {
      get {
        if case .subscriptionAdd(let v)? = value {return v}
        return Anytype_Event.Object.Subscription.Add()
      }
      set {value = .subscriptionAdd(newValue)}
    }

    public var subscriptionRemove: Anytype_Event.Object.Subscription.Remove {
      get {
        if case .subscriptionRemove(let v)? = value {return v}
        return Anytype_Event.Object.Subscription.Remove()
      }
      set {value = .subscriptionRemove(newValue)}
    }

    public var subscriptionPosition: Anytype_Event.Object.Subscription.Position {
      get {
        if case .subscriptionPosition(let v)? = value {return v}
        return Anytype_Event.Object.Subscription.Position()
      }
      set {value = .subscriptionPosition(newValue)}
    }

    public var subscriptionCounters: Anytype_Event.Object.Subscription.Counters {
      get {
        if case .subscriptionCounters(let v)? = value {return v}
        return Anytype_Event.Object.Subscription.Counters()
      }
      set {value = .subscriptionCounters(newValue)}
    }

    public var subscriptionGroups: Anytype_Event.Object.Subscription.Groups {
      get {
        if case .subscriptionGroups(let v)? = value {return v}
        return Anytype_Event.Object.Subscription.Groups()
      }
      set {value = .subscriptionGroups(newValue)}
    }

    public var blockAdd: Anytype_Event.Block.Add {
      get {
        if case .blockAdd(let v)? = value {return v}
        return Anytype_Event.Block.Add()
      }
      set {value = .blockAdd(newValue)}
    }

    public var blockDelete: Anytype_Event.Block.Delete {
      get {
        if case .blockDelete(let v)? = value {return v}
        return Anytype_Event.Block.Delete()
      }
      set {value = .blockDelete(newValue)}
    }

    public var filesUpload: Anytype_Event.Block.FilesUpload {
      get {
        if case .filesUpload(let v)? = value {return v}
        return Anytype_Event.Block.FilesUpload()
      }
      set {value = .filesUpload(newValue)}
    }

    public var marksInfo: Anytype_Event.Block.MarksInfo {
      get {
        if case .marksInfo(let v)? = value {return v}
        return Anytype_Event.Block.MarksInfo()
      }
      set {value = .marksInfo(newValue)}
    }

    public var blockSetFields: Anytype_Event.Block.Set.Fields {
      get {
        if case .blockSetFields(let v)? = value {return v}
        return Anytype_Event.Block.Set.Fields()
      }
      set {value = .blockSetFields(newValue)}
    }

    public var blockSetChildrenIds: Anytype_Event.Block.Set.ChildrenIds {
      get {
        if case .blockSetChildrenIds(let v)? = value {return v}
        return Anytype_Event.Block.Set.ChildrenIds()
      }
      set {value = .blockSetChildrenIds(newValue)}
    }

    public var blockSetRestrictions: Anytype_Event.Block.Set.Restrictions {
      get {
        if case .blockSetRestrictions(let v)? = value {return v}
        return Anytype_Event.Block.Set.Restrictions()
      }
      set {value = .blockSetRestrictions(newValue)}
    }

    public var blockSetBackgroundColor: Anytype_Event.Block.Set.BackgroundColor {
      get {
        if case .blockSetBackgroundColor(let v)? = value {return v}
        return Anytype_Event.Block.Set.BackgroundColor()
      }
      set {value = .blockSetBackgroundColor(newValue)}
    }

    public var blockSetText: Anytype_Event.Block.Set.Text {
      get {
        if case .blockSetText(let v)? = value {return v}
        return Anytype_Event.Block.Set.Text()
      }
      set {value = .blockSetText(newValue)}
    }

    public var blockSetFile: Anytype_Event.Block.Set.File {
      get {
        if case .blockSetFile(let v)? = value {return v}
        return Anytype_Event.Block.Set.File()
      }
      set {value = .blockSetFile(newValue)}
    }

    public var blockSetLink: Anytype_Event.Block.Set.Link {
      get {
        if case .blockSetLink(let v)? = value {return v}
        return Anytype_Event.Block.Set.Link()
      }
      set {value = .blockSetLink(newValue)}
    }

    public var blockSetBookmark: Anytype_Event.Block.Set.Bookmark {
      get {
        if case .blockSetBookmark(let v)? = value {return v}
        return Anytype_Event.Block.Set.Bookmark()
      }
      set {value = .blockSetBookmark(newValue)}
    }

    public var blockSetAlign: Anytype_Event.Block.Set.Align {
      get {
        if case .blockSetAlign(let v)? = value {return v}
        return Anytype_Event.Block.Set.Align()
      }
      set {value = .blockSetAlign(newValue)}
    }

    public var blockSetDiv: Anytype_Event.Block.Set.Div {
      get {
        if case .blockSetDiv(let v)? = value {return v}
        return Anytype_Event.Block.Set.Div()
      }
      set {value = .blockSetDiv(newValue)}
    }

    public var blockSetRelation: Anytype_Event.Block.Set.Relation {
      get {
        if case .blockSetRelation(let v)? = value {return v}
        return Anytype_Event.Block.Set.Relation()
      }
      set {value = .blockSetRelation(newValue)}
    }

    public var blockSetLatex: Anytype_Event.Block.Set.Latex {
      get {
        if case .blockSetLatex(let v)? = value {return v}
        return Anytype_Event.Block.Set.Latex()
      }
      set {value = .blockSetLatex(newValue)}
    }

    public var blockSetVerticalAlign: Anytype_Event.Block.Set.VerticalAlign {
      get {
        if case .blockSetVerticalAlign(let v)? = value {return v}
        return Anytype_Event.Block.Set.VerticalAlign()
      }
      set {value = .blockSetVerticalAlign(newValue)}
    }

    public var blockSetTableRow: Anytype_Event.Block.Set.TableRow {
      get {
        if case .blockSetTableRow(let v)? = value {return v}
        return Anytype_Event.Block.Set.TableRow()
      }
      set {value = .blockSetTableRow(newValue)}
    }

    public var blockSetWidget: Anytype_Event.Block.Set.Widget {
      get {
        if case .blockSetWidget(let v)? = value {return v}
        return Anytype_Event.Block.Set.Widget()
      }
      set {value = .blockSetWidget(newValue)}
    }

    public var blockDataviewViewSet: Anytype_Event.Block.Dataview.ViewSet {
      get {
        if case .blockDataviewViewSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.ViewSet()
      }
      set {value = .blockDataviewViewSet(newValue)}
    }

    public var blockDataviewViewDelete: Anytype_Event.Block.Dataview.ViewDelete {
      get {
        if case .blockDataviewViewDelete(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.ViewDelete()
      }
      set {value = .blockDataviewViewDelete(newValue)}
    }

    public var blockDataviewViewOrder: Anytype_Event.Block.Dataview.ViewOrder {
      get {
        if case .blockDataviewViewOrder(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.ViewOrder()
      }
      set {value = .blockDataviewViewOrder(newValue)}
    }

    /// deprecated, source is no longer used
    public var blockDataviewSourceSet: Anytype_Event.Block.Dataview.SourceSet {
      get {
        if case .blockDataviewSourceSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.SourceSet()
      }
      set {value = .blockDataviewSourceSet(newValue)}
    }

    public var blockDataViewGroupOrderUpdate: Anytype_Event.Block.Dataview.GroupOrderUpdate {
      get {
        if case .blockDataViewGroupOrderUpdate(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.GroupOrderUpdate()
      }
      set {value = .blockDataViewGroupOrderUpdate(newValue)}
    }

    public var blockDataViewObjectOrderUpdate: Anytype_Event.Block.Dataview.ObjectOrderUpdate {
      get {
        if case .blockDataViewObjectOrderUpdate(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.ObjectOrderUpdate()
      }
      set {value = .blockDataViewObjectOrderUpdate(newValue)}
    }

    public var blockDataviewRelationDelete: Anytype_Event.Block.Dataview.RelationDelete {
      get {
        if case .blockDataviewRelationDelete(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.RelationDelete()
      }
      set {value = .blockDataviewRelationDelete(newValue)}
    }

    public var blockDataviewRelationSet: Anytype_Event.Block.Dataview.RelationSet {
      get {
        if case .blockDataviewRelationSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.RelationSet()
      }
      set {value = .blockDataviewRelationSet(newValue)}
    }

    public var blockDataviewViewUpdate: Anytype_Event.Block.Dataview.ViewUpdate {
      get {
        if case .blockDataviewViewUpdate(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.ViewUpdate()
      }
      set {value = .blockDataviewViewUpdate(newValue)}
    }

    public var blockDataviewTargetObjectIDSet: Anytype_Event.Block.Dataview.TargetObjectIdSet {
      get {
        if case .blockDataviewTargetObjectIDSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.TargetObjectIdSet()
      }
      set {value = .blockDataviewTargetObjectIDSet(newValue)}
    }

    public var blockDataviewIsCollectionSet: Anytype_Event.Block.Dataview.IsCollectionSet {
      get {
        if case .blockDataviewIsCollectionSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.IsCollectionSet()
      }
      set {value = .blockDataviewIsCollectionSet(newValue)}
    }

    /// deprecated
    public var blockDataviewOldRelationDelete: Anytype_Event.Block.Dataview.OldRelationDelete {
      get {
        if case .blockDataviewOldRelationDelete(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.OldRelationDelete()
      }
      set {value = .blockDataviewOldRelationDelete(newValue)}
    }

    /// deprecated
    public var blockDataviewOldRelationSet: Anytype_Event.Block.Dataview.OldRelationSet {
      get {
        if case .blockDataviewOldRelationSet(let v)? = value {return v}
        return Anytype_Event.Block.Dataview.OldRelationSet()
      }
      set {value = .blockDataviewOldRelationSet(newValue)}
    }

    public var userBlockJoin: Anytype_Event.User.Block.Join {
      get {
        if case .userBlockJoin(let v)? = value {return v}
        return Anytype_Event.User.Block.Join()
      }
      set {value = .userBlockJoin(newValue)}
    }

    public var userBlockLeft: Anytype_Event.User.Block.Left {
      get {
        if case .userBlockLeft(let v)? = value {return v}
        return Anytype_Event.User.Block.Left()
      }
      set {value = .userBlockLeft(newValue)}
    }

    public var userBlockSelectRange: Anytype_Event.User.Block.SelectRange {
      get {
        if case .userBlockSelectRange(let v)? = value {return v}
        return Anytype_Event.User.Block.SelectRange()
      }
      set {value = .userBlockSelectRange(newValue)}
    }

    public var userBlockTextRange: Anytype_Event.User.Block.TextRange {
      get {
        if case .userBlockTextRange(let v)? = value {return v}
        return Anytype_Event.User.Block.TextRange()
      }
      set {value = .userBlockTextRange(newValue)}
    }

    public var ping: Anytype_Event.Ping {
      get {
        if case .ping(let v)? = value {return v}
        return Anytype_Event.Ping()
      }
      set {value = .ping(newValue)}
    }

    public var processNew: Anytype_Event.Process.New {
      get {
        if case .processNew(let v)? = value {return v}
        return Anytype_Event.Process.New()
      }
      set {value = .processNew(newValue)}
    }

    public var processUpdate: Anytype_Event.Process.Update {
      get {
        if case .processUpdate(let v)? = value {return v}
        return Anytype_Event.Process.Update()
      }
      set {value = .processUpdate(newValue)}
    }

    public var processDone: Anytype_Event.Process.Done {
      get {
        if case .processDone(let v)? = value {return v}
        return Anytype_Event.Process.Done()
      }
      set {value = .processDone(newValue)}
    }

    public var threadStatus: Anytype_Event.Status.Thread {
      get {
        if case .threadStatus(let v)? = value {return v}
        return Anytype_Event.Status.Thread()
      }
      set {value = .threadStatus(newValue)}
    }

    public var fileLimitReached: Anytype_Event.File.LimitReached {
      get {
        if case .fileLimitReached(let v)? = value {return v}
        return Anytype_Event.File.LimitReached()
      }
      set {value = .fileLimitReached(newValue)}
    }

    public var fileSpaceUsage: Anytype_Event.File.SpaceUsage {
      get {
        if case .fileSpaceUsage(let v)? = value {return v}
        return Anytype_Event.File.SpaceUsage()
      }
      set {value = .fileSpaceUsage(newValue)}
    }

    public var fileLocalUsage: Anytype_Event.File.LocalUsage {
      get {
        if case .fileLocalUsage(let v)? = value {return v}
        return Anytype_Event.File.LocalUsage()
      }
      set {value = .fileLocalUsage(newValue)}
    }

    public var fileLimitUpdated: Anytype_Event.File.LimitUpdated {
      get {
        if case .fileLimitUpdated(let v)? = value {return v}
        return Anytype_Event.File.LimitUpdated()
      }
      set {value = .fileLimitUpdated(newValue)}
    }

    public var notificationSend: Anytype_Event.Notification.Send {
      get {
        if case .notificationSend(let v)? = value {return v}
        return Anytype_Event.Notification.Send()
      }
      set {value = .notificationSend(newValue)}
    }

    public var notificationUpdate: Anytype_Event.Notification.Update {
      get {
        if case .notificationUpdate(let v)? = value {return v}
        return Anytype_Event.Notification.Update()
      }
      set {value = .notificationUpdate(newValue)}
    }

    public var payloadBroadcast: Anytype_Event.Payload.Broadcast {
      get {
        if case .payloadBroadcast(let v)? = value {return v}
        return Anytype_Event.Payload.Broadcast()
      }
      set {value = .payloadBroadcast(newValue)}
    }

    public var membershipUpdate: Anytype_Event.Membership.Update {
      get {
        if case .membershipUpdate(let v)? = value {return v}
        return Anytype_Event.Membership.Update()
      }
      set {value = .membershipUpdate(newValue)}
    }

    public var spaceSyncStatusUpdate: Anytype_Event.Space.SyncStatus.Update {
      get {
        if case .spaceSyncStatusUpdate(let v)? = value {return v}
        return Anytype_Event.Space.SyncStatus.Update()
      }
      set {value = .spaceSyncStatusUpdate(newValue)}
    }

    public var spaceAutoWidgetAdded: Anytype_Event.Space.AutoWidgetAdded {
      get {
        if case .spaceAutoWidgetAdded(let v)? = value {return v}
        return Anytype_Event.Space.AutoWidgetAdded()
      }
      set {value = .spaceAutoWidgetAdded(newValue)}
    }

    public var p2PStatusUpdate: Anytype_Event.P2PStatus.Update {
      get {
        if case .p2PStatusUpdate(let v)? = value {return v}
        return Anytype_Event.P2PStatus.Update()
      }
      set {value = .p2PStatusUpdate(newValue)}
    }

    public var importFinish: Anytype_Event.Import.Finish {
      get {
        if case .importFinish(let v)? = value {return v}
        return Anytype_Event.Import.Finish()
      }
      set {value = .importFinish(newValue)}
    }

    public var chatAdd: Anytype_Event.Chat.Add {
      get {
        if case .chatAdd(let v)? = value {return v}
        return Anytype_Event.Chat.Add()
      }
      set {value = .chatAdd(newValue)}
    }

    public var chatUpdate: Anytype_Event.Chat.Update {
      get {
        if case .chatUpdate(let v)? = value {return v}
        return Anytype_Event.Chat.Update()
      }
      set {value = .chatUpdate(newValue)}
    }

    public var chatUpdateReactions: Anytype_Event.Chat.UpdateReactions {
      get {
        if case .chatUpdateReactions(let v)? = value {return v}
        return Anytype_Event.Chat.UpdateReactions()
      }
      set {value = .chatUpdateReactions(newValue)}
    }

    /// received to update per-message read status (if needed to
    public var chatUpdateMessageReadStatus: Anytype_Event.Chat.UpdateMessageReadStatus {
      get {
        if case .chatUpdateMessageReadStatus(let v)? = value {return v}
        return Anytype_Event.Chat.UpdateMessageReadStatus()
      }
      set {value = .chatUpdateMessageReadStatus(newValue)}
    }

    /// highlight the unread messages in the UI)
    public var chatUpdateMentionReadStatus: Anytype_Event.Chat.UpdateMentionReadStatus {
      get {
        if case .chatUpdateMentionReadStatus(let v)? = value {return v}
        return Anytype_Event.Chat.UpdateMentionReadStatus()
      }
      set {value = .chatUpdateMentionReadStatus(newValue)}
    }

    /// to highlight the unread mentions in the UI)
    public var chatUpdateMessageSyncStatus: Anytype_Event.Chat.UpdateMessageSyncStatus {
      get {
        if case .chatUpdateMessageSyncStatus(let v)? = value {return v}
        return Anytype_Event.Chat.UpdateMessageSyncStatus()
      }
      set {value = .chatUpdateMessageSyncStatus(newValue)}
    }

    public var chatDelete: Anytype_Event.Chat.Delete {
      get {
        if case .chatDelete(let v)? = value {return v}
        return Anytype_Event.Chat.Delete()
      }
      set {value = .chatDelete(newValue)}
    }

    /// in case new unread messages received or chat state changed
    public var chatStateUpdate: Anytype_Event.Chat.UpdateState {
      get {
        if case .chatStateUpdate(let v)? = value {return v}
        return Anytype_Event.Chat.UpdateState()
      }
      set {value = .chatStateUpdate(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }    
}

extension Anytype_Event.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Event.protoMessageName + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    132: .same(proto: "spaceId"),
    1: .same(proto: "accountShow"),
    201: .same(proto: "accountDetails"),
    202: .same(proto: "accountConfigUpdate"),
    203: .same(proto: "accountUpdate"),
    204: .same(proto: "accountLinkChallenge"),
    205: .same(proto: "accountLinkChallengeHide"),
    16: .same(proto: "objectDetailsSet"),
    50: .same(proto: "objectDetailsAmend"),
    51: .same(proto: "objectDetailsUnset"),
    52: .same(proto: "objectRelationsAmend"),
    53: .same(proto: "objectRelationsRemove"),
    54: .same(proto: "objectRemove"),
    65: .same(proto: "objectClose"),
    55: .same(proto: "objectRestrictionsSet"),
    60: .same(proto: "subscriptionAdd"),
    61: .same(proto: "subscriptionRemove"),
    62: .same(proto: "subscriptionPosition"),
    63: .same(proto: "subscriptionCounters"),
    64: .same(proto: "subscriptionGroups"),
    2: .same(proto: "blockAdd"),
    3: .same(proto: "blockDelete"),
    4: .same(proto: "filesUpload"),
    5: .same(proto: "marksInfo"),
    6: .same(proto: "blockSetFields"),
    7: .same(proto: "blockSetChildrenIds"),
    8: .same(proto: "blockSetRestrictions"),
    9: .same(proto: "blockSetBackgroundColor"),
    10: .same(proto: "blockSetText"),
    11: .same(proto: "blockSetFile"),
    13: .same(proto: "blockSetLink"),
    14: .same(proto: "blockSetBookmark"),
    15: .same(proto: "blockSetAlign"),
    17: .same(proto: "blockSetDiv"),
    21: .same(proto: "blockSetRelation"),
    25: .same(proto: "blockSetLatex"),
    36: .same(proto: "blockSetVerticalAlign"),
    37: .same(proto: "blockSetTableRow"),
    40: .same(proto: "blockSetWidget"),
    19: .same(proto: "blockDataviewViewSet"),
    20: .same(proto: "blockDataviewViewDelete"),
    29: .same(proto: "blockDataviewViewOrder"),
    35: .same(proto: "blockDataviewSourceSet"),
    38: .same(proto: "blockDataViewGroupOrderUpdate"),
    39: .same(proto: "blockDataViewObjectOrderUpdate"),
    124: .same(proto: "blockDataviewRelationDelete"),
    123: .same(proto: "blockDataviewRelationSet"),
    125: .same(proto: "blockDataviewViewUpdate"),
    126: .same(proto: "blockDataviewTargetObjectIdSet"),
    127: .same(proto: "blockDataviewIsCollectionSet"),
    24: .same(proto: "blockDataviewOldRelationDelete"),
    23: .same(proto: "blockDataviewOldRelationSet"),
    31: .same(proto: "userBlockJoin"),
    32: .same(proto: "userBlockLeft"),
    33: .same(proto: "userBlockSelectRange"),
    34: .same(proto: "userBlockTextRange"),
    100: .same(proto: "ping"),
    101: .same(proto: "processNew"),
    102: .same(proto: "processUpdate"),
    103: .same(proto: "processDone"),
    110: .same(proto: "threadStatus"),
    111: .same(proto: "fileLimitReached"),
    112: .same(proto: "fileSpaceUsage"),
    113: .same(proto: "fileLocalUsage"),
    118: .same(proto: "fileLimitUpdated"),
    114: .same(proto: "notificationSend"),
    115: .same(proto: "notificationUpdate"),
    116: .same(proto: "payloadBroadcast"),
    117: .same(proto: "membershipUpdate"),
    119: .same(proto: "spaceSyncStatusUpdate"),
    122: .same(proto: "spaceAutoWidgetAdded"),
    120: .same(proto: "p2pStatusUpdate"),
    121: .same(proto: "importFinish"),
    128: .same(proto: "chatAdd"),
    129: .same(proto: "chatUpdate"),
    130: .same(proto: "chatUpdateReactions"),
    134: .same(proto: "chatUpdateMessageReadStatus"),
    135: .same(proto: "chatUpdateMentionReadStatus"),
    136: .same(proto: "chatUpdateMessageSyncStatus"),
    131: .same(proto: "chatDelete"),
    133: .same(proto: "chatStateUpdate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anytype_Event.Account.Show?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountShow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountShow(v)
        }
      }()
      case 2: try {
        var v: Anytype_Event.Block.Add?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockAdd(v)
        }
      }()
      case 3: try {
        var v: Anytype_Event.Block.Delete?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDelete(v)
        }
      }()
      case 4: try {
        var v: Anytype_Event.Block.FilesUpload?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .filesUpload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .filesUpload(v)
        }
      }()
      case 5: try {
        var v: Anytype_Event.Block.MarksInfo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .marksInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .marksInfo(v)
        }
      }()
      case 6: try {
        var v: Anytype_Event.Block.Set.Fields?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetFields(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetFields(v)
        }
      }()
      case 7: try {
        var v: Anytype_Event.Block.Set.ChildrenIds?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetChildrenIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetChildrenIds(v)
        }
      }()
      case 8: try {
        var v: Anytype_Event.Block.Set.Restrictions?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetRestrictions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetRestrictions(v)
        }
      }()
      case 9: try {
        var v: Anytype_Event.Block.Set.BackgroundColor?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetBackgroundColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetBackgroundColor(v)
        }
      }()
      case 10: try {
        var v: Anytype_Event.Block.Set.Text?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetText(v)
        }
      }()
      case 11: try {
        var v: Anytype_Event.Block.Set.File?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetFile(v)
        }
      }()
      case 13: try {
        var v: Anytype_Event.Block.Set.Link?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetLink(v)
        }
      }()
      case 14: try {
        var v: Anytype_Event.Block.Set.Bookmark?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetBookmark(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetBookmark(v)
        }
      }()
      case 15: try {
        var v: Anytype_Event.Block.Set.Align?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetAlign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetAlign(v)
        }
      }()
      case 16: try {
        var v: Anytype_Event.Object.Details.Set?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectDetailsSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectDetailsSet(v)
        }
      }()
      case 17: try {
        var v: Anytype_Event.Block.Set.Div?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetDiv(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetDiv(v)
        }
      }()
      case 19: try {
        var v: Anytype_Event.Block.Dataview.ViewSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewViewSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewViewSet(v)
        }
      }()
      case 20: try {
        var v: Anytype_Event.Block.Dataview.ViewDelete?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewViewDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewViewDelete(v)
        }
      }()
      case 21: try {
        var v: Anytype_Event.Block.Set.Relation?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetRelation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetRelation(v)
        }
      }()
      case 23: try {
        var v: Anytype_Event.Block.Dataview.OldRelationSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewOldRelationSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewOldRelationSet(v)
        }
      }()
      case 24: try {
        var v: Anytype_Event.Block.Dataview.OldRelationDelete?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewOldRelationDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewOldRelationDelete(v)
        }
      }()
      case 25: try {
        var v: Anytype_Event.Block.Set.Latex?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetLatex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetLatex(v)
        }
      }()
      case 29: try {
        var v: Anytype_Event.Block.Dataview.ViewOrder?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewViewOrder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewViewOrder(v)
        }
      }()
      case 31: try {
        var v: Anytype_Event.User.Block.Join?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userBlockJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userBlockJoin(v)
        }
      }()
      case 32: try {
        var v: Anytype_Event.User.Block.Left?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userBlockLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userBlockLeft(v)
        }
      }()
      case 33: try {
        var v: Anytype_Event.User.Block.SelectRange?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userBlockSelectRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userBlockSelectRange(v)
        }
      }()
      case 34: try {
        var v: Anytype_Event.User.Block.TextRange?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userBlockTextRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userBlockTextRange(v)
        }
      }()
      case 35: try {
        var v: Anytype_Event.Block.Dataview.SourceSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewSourceSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewSourceSet(v)
        }
      }()
      case 36: try {
        var v: Anytype_Event.Block.Set.VerticalAlign?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetVerticalAlign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetVerticalAlign(v)
        }
      }()
      case 37: try {
        var v: Anytype_Event.Block.Set.TableRow?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetTableRow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetTableRow(v)
        }
      }()
      case 38: try {
        var v: Anytype_Event.Block.Dataview.GroupOrderUpdate?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataViewGroupOrderUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataViewGroupOrderUpdate(v)
        }
      }()
      case 39: try {
        var v: Anytype_Event.Block.Dataview.ObjectOrderUpdate?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataViewObjectOrderUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataViewObjectOrderUpdate(v)
        }
      }()
      case 40: try {
        var v: Anytype_Event.Block.Set.Widget?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockSetWidget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockSetWidget(v)
        }
      }()
      case 50: try {
        var v: Anytype_Event.Object.Details.Amend?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectDetailsAmend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectDetailsAmend(v)
        }
      }()
      case 51: try {
        var v: Anytype_Event.Object.Details.Unset?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectDetailsUnset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectDetailsUnset(v)
        }
      }()
      case 52: try {
        var v: Anytype_Event.Object.Relations.Amend?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectRelationsAmend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectRelationsAmend(v)
        }
      }()
      case 53: try {
        var v: Anytype_Event.Object.Relations.Remove?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectRelationsRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectRelationsRemove(v)
        }
      }()
      case 54: try {
        var v: Anytype_Event.Object.Remove?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectRemove(v)
        }
      }()
      case 55: try {
        var v: Anytype_Event.Object.Restrictions.Set?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectRestrictionsSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectRestrictionsSet(v)
        }
      }()
      case 60: try {
        var v: Anytype_Event.Object.Subscription.Add?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriptionAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriptionAdd(v)
        }
      }()
      case 61: try {
        var v: Anytype_Event.Object.Subscription.Remove?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriptionRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriptionRemove(v)
        }
      }()
      case 62: try {
        var v: Anytype_Event.Object.Subscription.Position?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriptionPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriptionPosition(v)
        }
      }()
      case 63: try {
        var v: Anytype_Event.Object.Subscription.Counters?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriptionCounters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriptionCounters(v)
        }
      }()
      case 64: try {
        var v: Anytype_Event.Object.Subscription.Groups?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriptionGroups(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriptionGroups(v)
        }
      }()
      case 65: try {
        var v: Anytype_Event.Object.Close?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .objectClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .objectClose(v)
        }
      }()
      case 100: try {
        var v: Anytype_Event.Ping?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ping(v)
        }
      }()
      case 101: try {
        var v: Anytype_Event.Process.New?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processNew(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processNew(v)
        }
      }()
      case 102: try {
        var v: Anytype_Event.Process.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processUpdate(v)
        }
      }()
      case 103: try {
        var v: Anytype_Event.Process.Done?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processDone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processDone(v)
        }
      }()
      case 110: try {
        var v: Anytype_Event.Status.Thread?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .threadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .threadStatus(v)
        }
      }()
      case 111: try {
        var v: Anytype_Event.File.LimitReached?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fileLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fileLimitReached(v)
        }
      }()
      case 112: try {
        var v: Anytype_Event.File.SpaceUsage?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fileSpaceUsage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fileSpaceUsage(v)
        }
      }()
      case 113: try {
        var v: Anytype_Event.File.LocalUsage?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fileLocalUsage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fileLocalUsage(v)
        }
      }()
      case 114: try {
        var v: Anytype_Event.Notification.Send?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .notificationSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .notificationSend(v)
        }
      }()
      case 115: try {
        var v: Anytype_Event.Notification.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .notificationUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .notificationUpdate(v)
        }
      }()
      case 116: try {
        var v: Anytype_Event.Payload.Broadcast?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .payloadBroadcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .payloadBroadcast(v)
        }
      }()
      case 117: try {
        var v: Anytype_Event.Membership.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .membershipUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .membershipUpdate(v)
        }
      }()
      case 118: try {
        var v: Anytype_Event.File.LimitUpdated?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fileLimitUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fileLimitUpdated(v)
        }
      }()
      case 119: try {
        var v: Anytype_Event.Space.SyncStatus.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .spaceSyncStatusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .spaceSyncStatusUpdate(v)
        }
      }()
      case 120: try {
        var v: Anytype_Event.P2PStatus.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .p2PStatusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .p2PStatusUpdate(v)
        }
      }()
      case 121: try {
        var v: Anytype_Event.Import.Finish?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .importFinish(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .importFinish(v)
        }
      }()
      case 122: try {
        var v: Anytype_Event.Space.AutoWidgetAdded?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .spaceAutoWidgetAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .spaceAutoWidgetAdded(v)
        }
      }()
      case 123: try {
        var v: Anytype_Event.Block.Dataview.RelationSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewRelationSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewRelationSet(v)
        }
      }()
      case 124: try {
        var v: Anytype_Event.Block.Dataview.RelationDelete?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewRelationDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewRelationDelete(v)
        }
      }()
      case 125: try {
        var v: Anytype_Event.Block.Dataview.ViewUpdate?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewViewUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewViewUpdate(v)
        }
      }()
      case 126: try {
        var v: Anytype_Event.Block.Dataview.TargetObjectIdSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewTargetObjectIDSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewTargetObjectIDSet(v)
        }
      }()
      case 127: try {
        var v: Anytype_Event.Block.Dataview.IsCollectionSet?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blockDataviewIsCollectionSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blockDataviewIsCollectionSet(v)
        }
      }()
      case 128: try {
        var v: Anytype_Event.Chat.Add?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatAdd(v)
        }
      }()
      case 129: try {
        var v: Anytype_Event.Chat.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatUpdate(v)
        }
      }()
      case 130: try {
        var v: Anytype_Event.Chat.UpdateReactions?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatUpdateReactions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatUpdateReactions(v)
        }
      }()
      case 131: try {
        var v: Anytype_Event.Chat.Delete?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatDelete(v)
        }
      }()
      case 132: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 133: try {
        var v: Anytype_Event.Chat.UpdateState?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatStateUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatStateUpdate(v)
        }
      }()
      case 134: try {
        var v: Anytype_Event.Chat.UpdateMessageReadStatus?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatUpdateMessageReadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatUpdateMessageReadStatus(v)
        }
      }()
      case 135: try {
        var v: Anytype_Event.Chat.UpdateMentionReadStatus?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatUpdateMentionReadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatUpdateMentionReadStatus(v)
        }
      }()
      case 136: try {
        var v: Anytype_Event.Chat.UpdateMessageSyncStatus?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .chatUpdateMessageSyncStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .chatUpdateMessageSyncStatus(v)
        }
      }()
      case 201: try {
        var v: Anytype_Event.Account.Details?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountDetails(v)
        }
      }()
      case 202: try {
        var v: Anytype_Event.Account.Config.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountConfigUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountConfigUpdate(v)
        }
      }()
      case 203: try {
        var v: Anytype_Event.Account.Update?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountUpdate(v)
        }
      }()
      case 204: try {
        var v: Anytype_Event.Account.LinkChallenge?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountLinkChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountLinkChallenge(v)
        }
      }()
      case 205: try {
        var v: Anytype_Event.Account.LinkChallengeHide?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .accountLinkChallengeHide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .accountLinkChallengeHide(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .accountShow?: try {
      guard case .accountShow(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .blockAdd?: try {
      guard case .blockAdd(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .blockDelete?: try {
      guard case .blockDelete(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .filesUpload?: try {
      guard case .filesUpload(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .marksInfo?: try {
      guard case .marksInfo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .blockSetFields?: try {
      guard case .blockSetFields(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .blockSetChildrenIds?: try {
      guard case .blockSetChildrenIds(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .blockSetRestrictions?: try {
      guard case .blockSetRestrictions(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .blockSetBackgroundColor?: try {
      guard case .blockSetBackgroundColor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .blockSetText?: try {
      guard case .blockSetText(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .blockSetFile?: try {
      guard case .blockSetFile(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .blockSetLink?: try {
      guard case .blockSetLink(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .blockSetBookmark?: try {
      guard case .blockSetBookmark(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .blockSetAlign?: try {
      guard case .blockSetAlign(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .objectDetailsSet?: try {
      guard case .objectDetailsSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .blockSetDiv?: try {
      guard case .blockSetDiv(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .blockDataviewViewSet?: try {
      guard case .blockDataviewViewSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .blockDataviewViewDelete?: try {
      guard case .blockDataviewViewDelete(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .blockSetRelation?: try {
      guard case .blockSetRelation(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .blockDataviewOldRelationSet?: try {
      guard case .blockDataviewOldRelationSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .blockDataviewOldRelationDelete?: try {
      guard case .blockDataviewOldRelationDelete(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .blockSetLatex?: try {
      guard case .blockSetLatex(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .blockDataviewViewOrder?: try {
      guard case .blockDataviewViewOrder(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .userBlockJoin?: try {
      guard case .userBlockJoin(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .userBlockLeft?: try {
      guard case .userBlockLeft(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .userBlockSelectRange?: try {
      guard case .userBlockSelectRange(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .userBlockTextRange?: try {
      guard case .userBlockTextRange(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .blockDataviewSourceSet?: try {
      guard case .blockDataviewSourceSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .blockSetVerticalAlign?: try {
      guard case .blockSetVerticalAlign(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .blockSetTableRow?: try {
      guard case .blockSetTableRow(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .blockDataViewGroupOrderUpdate?: try {
      guard case .blockDataViewGroupOrderUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .blockDataViewObjectOrderUpdate?: try {
      guard case .blockDataViewObjectOrderUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .blockSetWidget?: try {
      guard case .blockSetWidget(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .objectDetailsAmend?: try {
      guard case .objectDetailsAmend(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .objectDetailsUnset?: try {
      guard case .objectDetailsUnset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .objectRelationsAmend?: try {
      guard case .objectRelationsAmend(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .objectRelationsRemove?: try {
      guard case .objectRelationsRemove(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .objectRemove?: try {
      guard case .objectRemove(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .objectRestrictionsSet?: try {
      guard case .objectRestrictionsSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .subscriptionAdd?: try {
      guard case .subscriptionAdd(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .subscriptionRemove?: try {
      guard case .subscriptionRemove(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .subscriptionPosition?: try {
      guard case .subscriptionPosition(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .subscriptionCounters?: try {
      guard case .subscriptionCounters(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
    }()
    case .subscriptionGroups?: try {
      guard case .subscriptionGroups(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }()
    case .objectClose?: try {
      guard case .objectClose(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .processNew?: try {
      guard case .processNew(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .processUpdate?: try {
      guard case .processUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .processDone?: try {
      guard case .processDone(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .threadStatus?: try {
      guard case .threadStatus(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .fileLimitReached?: try {
      guard case .fileLimitReached(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .fileSpaceUsage?: try {
      guard case .fileSpaceUsage(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .fileLocalUsage?: try {
      guard case .fileLocalUsage(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .notificationSend?: try {
      guard case .notificationSend(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .notificationUpdate?: try {
      guard case .notificationUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .payloadBroadcast?: try {
      guard case .payloadBroadcast(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .membershipUpdate?: try {
      guard case .membershipUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .fileLimitUpdated?: try {
      guard case .fileLimitUpdated(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .spaceSyncStatusUpdate?: try {
      guard case .spaceSyncStatusUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .p2PStatusUpdate?: try {
      guard case .p2PStatusUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
    }()
    case .importFinish?: try {
      guard case .importFinish(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .spaceAutoWidgetAdded?: try {
      guard case .spaceAutoWidgetAdded(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .blockDataviewRelationSet?: try {
      guard case .blockDataviewRelationSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .blockDataviewRelationDelete?: try {
      guard case .blockDataviewRelationDelete(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case .blockDataviewViewUpdate?: try {
      guard case .blockDataviewViewUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
    }()
    case .blockDataviewTargetObjectIDSet?: try {
      guard case .blockDataviewTargetObjectIDSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
    }()
    case .blockDataviewIsCollectionSet?: try {
      guard case .blockDataviewIsCollectionSet(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
    }()
    case .chatAdd?: try {
      guard case .chatAdd(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
    }()
    case .chatUpdate?: try {
      guard case .chatUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .chatUpdateReactions?: try {
      guard case .chatUpdateReactions(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .chatDelete?: try {
      guard case .chatDelete(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
    }()
    default: break
    }
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 132)
    }
    switch self.value {
    case .chatStateUpdate?: try {
      guard case .chatStateUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
    }()
    case .chatUpdateMessageReadStatus?: try {
      guard case .chatUpdateMessageReadStatus(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
    }()
    case .chatUpdateMentionReadStatus?: try {
      guard case .chatUpdateMentionReadStatus(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
    }()
    case .chatUpdateMessageSyncStatus?: try {
      guard case .chatUpdateMessageSyncStatus(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
    }()
    case .accountDetails?: try {
      guard case .accountDetails(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .accountConfigUpdate?: try {
      guard case .accountConfigUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case .accountUpdate?: try {
      guard case .accountUpdate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 203)
    }()
    case .accountLinkChallenge?: try {
      guard case .accountLinkChallenge(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 204)
    }()
    case .accountLinkChallengeHide?: try {
      guard case .accountLinkChallengeHide(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 205)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Event.Message, rhs: Anytype_Event.Message) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype"
