// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pkg/lib/pb/model/protos/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Anytype_Model_SmartBlockType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// deprecated
  case accountOld // = 0
  case page // = 16
  case profilePage // = 17
  case home // = 32
  case archive // = 48
  case widget // = 112
  case file // = 256
  case template // = 288
  case bundledTemplate // = 289

  /// DEPRECATED
  case bundledRelation // = 512
  case subObject // = 513

  /// DEPRECATED
  case bundledObjectType // = 514
  case anytypeProfile // = 515
  case date // = 516
  case workspace // = 518
  case strelation // = 521
  case sttype // = 528
  case strelationOption // = 529
  case spaceView // = 530
  case identity // = 532
  case participant // = 534
  case missingObject // = 519
  case fileObject // = 533
  case notificationObject // = 535
  case UNRECOGNIZED(Int)

  public init() {
    self = .accountOld
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .accountOld
    case 16: self = .page
    case 17: self = .profilePage
    case 32: self = .home
    case 48: self = .archive
    case 112: self = .widget
    case 256: self = .file
    case 288: self = .template
    case 289: self = .bundledTemplate
    case 512: self = .bundledRelation
    case 513: self = .subObject
    case 514: self = .bundledObjectType
    case 515: self = .anytypeProfile
    case 516: self = .date
    case 518: self = .workspace
    case 519: self = .missingObject
    case 521: self = .strelation
    case 528: self = .sttype
    case 529: self = .strelationOption
    case 530: self = .spaceView
    case 532: self = .identity
    case 533: self = .fileObject
    case 534: self = .participant
    case 535: self = .notificationObject
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .accountOld: return 0
    case .page: return 16
    case .profilePage: return 17
    case .home: return 32
    case .archive: return 48
    case .widget: return 112
    case .file: return 256
    case .template: return 288
    case .bundledTemplate: return 289
    case .bundledRelation: return 512
    case .subObject: return 513
    case .bundledObjectType: return 514
    case .anytypeProfile: return 515
    case .date: return 516
    case .workspace: return 518
    case .missingObject: return 519
    case .strelation: return 521
    case .sttype: return 528
    case .strelationOption: return 529
    case .spaceView: return 530
    case .identity: return 532
    case .fileObject: return 533
    case .participant: return 534
    case .notificationObject: return 535
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_SmartBlockType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_SmartBlockType] = [
    .accountOld,
    .page,
    .profilePage,
    .home,
    .archive,
    .widget,
    .file,
    .template,
    .bundledTemplate,
    .bundledRelation,
    .subObject,
    .bundledObjectType,
    .anytypeProfile,
    .date,
    .workspace,
    .strelation,
    .sttype,
    .strelationOption,
    .spaceView,
    .identity,
    .participant,
    .missingObject,
    .fileObject,
    .notificationObject,
  ]
}

#endif  // swift(>=4.2)

/// RelationFormat describes how the underlying data is stored in the google.protobuf.Value and how it should be validated/sanitized
public enum Anytype_Model_RelationFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// string
  case longtext // = 0

  /// string, usually short enough. May be truncated in the future
  case shorttext // = 1

  /// double
  case number // = 2

  /// string or list of string(len==1)
  case status // = 3

  /// list of string (choose multiple from a list)
  case tag // = 11

  /// float64(pb.Value doesn't have int64) or the string
  case date // = 4

  /// relation can has objects of specific types: file, image, audio, video
  case file // = 5

  /// boolean
  case checkbox // = 6

  /// string with sanity check
  case url // = 7

  /// string with sanity check
  case email // = 8

  /// string with sanity check
  case phone // = 9

  /// one emoji, can contains multiple utf-8 symbols
  case emoji // = 10

  /// relation can has objectType to specify objectType
  case object // = 100

  /// base64-encoded relation pb model
  case relations // = 101
  case UNRECOGNIZED(Int)

  public init() {
    self = .longtext
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .longtext
    case 1: self = .shorttext
    case 2: self = .number
    case 3: self = .status
    case 4: self = .date
    case 5: self = .file
    case 6: self = .checkbox
    case 7: self = .url
    case 8: self = .email
    case 9: self = .phone
    case 10: self = .emoji
    case 11: self = .tag
    case 100: self = .object
    case 101: self = .relations
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .longtext: return 0
    case .shorttext: return 1
    case .number: return 2
    case .status: return 3
    case .date: return 4
    case .file: return 5
    case .checkbox: return 6
    case .url: return 7
    case .email: return 8
    case .phone: return 9
    case .emoji: return 10
    case .tag: return 11
    case .object: return 100
    case .relations: return 101
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_RelationFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_RelationFormat] = [
    .longtext,
    .shorttext,
    .number,
    .status,
    .tag,
    .date,
    .file,
    .checkbox,
    .url,
    .email,
    .phone,
    .emoji,
    .object,
    .relations,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_ObjectOrigin: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0
  case clipboard // = 1
  case dragAndDrop // = 2
  case `import` // = 3
  case webclipper // = 4
  case sharingExtension // = 5
  case usecase // = 6
  case builtin // = 7
  case bookmark // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .clipboard
    case 2: self = .dragAndDrop
    case 3: self = .import
    case 4: self = .webclipper
    case 5: self = .sharingExtension
    case 6: self = .usecase
    case 7: self = .builtin
    case 8: self = .bookmark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .clipboard: return 1
    case .dragAndDrop: return 2
    case .import: return 3
    case .webclipper: return 4
    case .sharingExtension: return 5
    case .usecase: return 6
    case .builtin: return 7
    case .bookmark: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_ObjectOrigin: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_ObjectOrigin] = [
    .none,
    .clipboard,
    .dragAndDrop,
    .import,
    .webclipper,
    .sharingExtension,
    .usecase,
    .builtin,
    .bookmark,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_SpaceStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown means the space is not loaded yet
  case unknown // = 0

  /// Loading - the space in progress of loading
  case loading // = 1

  /// Ok - the space loaded and available
  case ok // = 2

  /// Missing - the space is missing
  case missing // = 3

  /// Error - the space loading ended with an error
  case error // = 4

  /// RemoteWaitingDeletion - network status is "waiting deletion"
  case remoteWaitingDeletion // = 5

  /// RemoteDeleted - the space is deleted in the current network
  case remoteDeleted // = 6

  /// SpaceDeleted - the space should be deleted in the network
  case spaceDeleted // = 7

  /// SpaceActive - the space is active in the network
  case spaceActive // = 8

  /// SpaceJoining - the account is joining the space
  case spaceJoining // = 9

  /// SpaceRemoving - the account is removing from space or the space is removed from network
  case spaceRemoving // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .loading
    case 2: self = .ok
    case 3: self = .missing
    case 4: self = .error
    case 5: self = .remoteWaitingDeletion
    case 6: self = .remoteDeleted
    case 7: self = .spaceDeleted
    case 8: self = .spaceActive
    case 9: self = .spaceJoining
    case 10: self = .spaceRemoving
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .loading: return 1
    case .ok: return 2
    case .missing: return 3
    case .error: return 4
    case .remoteWaitingDeletion: return 5
    case .remoteDeleted: return 6
    case .spaceDeleted: return 7
    case .spaceActive: return 8
    case .spaceJoining: return 9
    case .spaceRemoving: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_SpaceStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_SpaceStatus] = [
    .unknown,
    .loading,
    .ok,
    .missing,
    .error,
    .remoteWaitingDeletion,
    .remoteDeleted,
    .spaceDeleted,
    .spaceActive,
    .spaceJoining,
    .spaceRemoving,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_ParticipantPermissions: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case reader // = 0
  case writer // = 1
  case owner // = 2
  case noPermissions // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .reader
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .reader
    case 1: self = .writer
    case 2: self = .owner
    case 3: self = .noPermissions
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .reader: return 0
    case .writer: return 1
    case .owner: return 2
    case .noPermissions: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_ParticipantPermissions: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_ParticipantPermissions] = [
    .reader,
    .writer,
    .owner,
    .noPermissions,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_ParticipantStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case joining // = 0
  case active // = 1
  case removed // = 2
  case declined // = 3
  case removing // = 4
  case canceled // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .joining
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .joining
    case 1: self = .active
    case 2: self = .removed
    case 3: self = .declined
    case 4: self = .removing
    case 5: self = .canceled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .joining: return 0
    case .active: return 1
    case .removed: return 2
    case .declined: return 3
    case .removing: return 4
    case .canceled: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_ParticipantStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_ParticipantStatus] = [
    .joining,
    .active,
    .removed,
    .declined,
    .removing,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_SpaceAccessType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case `private` // = 0
  case personal // = 1
  case shared // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .private
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .private
    case 1: self = .personal
    case 2: self = .shared
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .private: return 0
    case .personal: return 1
    case .shared: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_SpaceAccessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_SpaceAccessType] = [
    .private,
    .personal,
    .shared,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_ImageKind: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case basic // = 0
  case cover // = 1
  case icon // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .basic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .basic
    case 1: self = .cover
    case 2: self = .icon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .basic: return 0
    case .cover: return 1
    case .icon: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_ImageKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_ImageKind] = [
    .basic,
    .cover,
    .icon,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_FileIndexingStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notIndexed // = 0
  case indexed // = 1
  case notFound // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notIndexed
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notIndexed
    case 1: self = .indexed
    case 2: self = .notFound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notIndexed: return 0
    case .indexed: return 1
    case .notFound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_FileIndexingStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_FileIndexingStatus] = [
    .notIndexed,
    .indexed,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_SpaceShareableStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case statusUnknown // = 0
  case statusShareable // = 1
  case statusNotShareable // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .statusUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnknown
    case 1: self = .statusShareable
    case 2: self = .statusNotShareable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .statusUnknown: return 0
    case .statusShareable: return 1
    case .statusNotShareable: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_SpaceShareableStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_SpaceShareableStatus] = [
    .statusUnknown,
    .statusShareable,
    .statusNotShareable,
  ]
}

#endif  // swift(>=4.2)

public enum Anytype_Model_NameserviceNameType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// .any suffix
  case anyName // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .anyName
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .anyName
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .anyName: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anytype_Model_NameserviceNameType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_NameserviceNameType] = [
    .anyName,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_SmartBlockSnapshotBase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blocks: [Anytype_Model_Block] = []

  public var details: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {self._details = nil}

  public var fileKeys: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _fileKeys ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_fileKeys = newValue}
  }
  /// Returns true if `fileKeys` has been explicitly set.
  public var hasFileKeys: Bool {return self._fileKeys != nil}
  /// Clears the value of `fileKeys`. Subsequent reads from it will return its default value.
  public mutating func clearFileKeys() {self._fileKeys = nil}

  public var extraRelations: [Anytype_Model_Relation] = []

  public var objectTypes: [String] = []

  public var collections: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _collections ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_collections = newValue}
  }
  /// Returns true if `collections` has been explicitly set.
  public var hasCollections: Bool {return self._collections != nil}
  /// Clears the value of `collections`. Subsequent reads from it will return its default value.
  public mutating func clearCollections() {self._collections = nil}

  public var removedCollectionKeys: [String] = []

  public var relationLinks: [Anytype_Model_RelationLink] = []

  /// only used for pb backup purposes, ignored in other cases
  public var key: String = String()

  /// ignored in import/export in favor of createdDate relation. Used to store original user-side object creation timestamp
  public var originalCreatedTimestamp: Int64 = 0

  public var fileInfo: Anytype_Model_FileInfo {
    get {return _fileInfo ?? Anytype_Model_FileInfo()}
    set {_fileInfo = newValue}
  }
  /// Returns true if `fileInfo` has been explicitly set.
  public var hasFileInfo: Bool {return self._fileInfo != nil}
  /// Clears the value of `fileInfo`. Subsequent reads from it will return its default value.
  public mutating func clearFileInfo() {self._fileInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _fileKeys: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _collections: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _fileInfo: Anytype_Model_FileInfo? = nil
}

public struct Anytype_Model_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var fields: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return _storage._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {_uniqueStorage()._fields = nil}

  public var restrictions: Anytype_Model_Block.Restrictions {
    get {return _storage._restrictions ?? Anytype_Model_Block.Restrictions()}
    set {_uniqueStorage()._restrictions = newValue}
  }
  /// Returns true if `restrictions` has been explicitly set.
  public var hasRestrictions: Bool {return _storage._restrictions != nil}
  /// Clears the value of `restrictions`. Subsequent reads from it will return its default value.
  public mutating func clearRestrictions() {_uniqueStorage()._restrictions = nil}

  public var childrenIds: [String] {
    get {return _storage._childrenIds}
    set {_uniqueStorage()._childrenIds = newValue}
  }

  public var backgroundColor: String {
    get {return _storage._backgroundColor}
    set {_uniqueStorage()._backgroundColor = newValue}
  }

  public var align: Anytype_Model_Block.Align {
    get {return _storage._align}
    set {_uniqueStorage()._align = newValue}
  }

  public var verticalAlign: Anytype_Model_Block.VerticalAlign {
    get {return _storage._verticalAlign}
    set {_uniqueStorage()._verticalAlign = newValue}
  }

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var smartblock: Anytype_Model_Block.Content.Smartblock {
    get {
      if case .smartblock(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Smartblock()
    }
    set {_uniqueStorage()._content = .smartblock(newValue)}
  }

  public var text: Anytype_Model_Block.Content.Text {
    get {
      if case .text(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Text()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  public var file: Anytype_Model_Block.Content.File {
    get {
      if case .file(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.File()
    }
    set {_uniqueStorage()._content = .file(newValue)}
  }

  public var layout: Anytype_Model_Block.Content.Layout {
    get {
      if case .layout(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Layout()
    }
    set {_uniqueStorage()._content = .layout(newValue)}
  }

  public var div: Anytype_Model_Block.Content.Div {
    get {
      if case .div(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Div()
    }
    set {_uniqueStorage()._content = .div(newValue)}
  }

  public var bookmark: Anytype_Model_Block.Content.Bookmark {
    get {
      if case .bookmark(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Bookmark()
    }
    set {_uniqueStorage()._content = .bookmark(newValue)}
  }

  public var icon: Anytype_Model_Block.Content.Icon {
    get {
      if case .icon(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Icon()
    }
    set {_uniqueStorage()._content = .icon(newValue)}
  }

  public var link: Anytype_Model_Block.Content.Link {
    get {
      if case .link(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Link()
    }
    set {_uniqueStorage()._content = .link(newValue)}
  }

  public var dataview: Anytype_Model_Block.Content.Dataview {
    get {
      if case .dataview(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Dataview()
    }
    set {_uniqueStorage()._content = .dataview(newValue)}
  }

  public var relation: Anytype_Model_Block.Content.Relation {
    get {
      if case .relation(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Relation()
    }
    set {_uniqueStorage()._content = .relation(newValue)}
  }

  public var featuredRelations: Anytype_Model_Block.Content.FeaturedRelations {
    get {
      if case .featuredRelations(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.FeaturedRelations()
    }
    set {_uniqueStorage()._content = .featuredRelations(newValue)}
  }

  public var latex: Anytype_Model_Block.Content.Latex {
    get {
      if case .latex(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Latex()
    }
    set {_uniqueStorage()._content = .latex(newValue)}
  }

  public var tableOfContents: Anytype_Model_Block.Content.TableOfContents {
    get {
      if case .tableOfContents(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.TableOfContents()
    }
    set {_uniqueStorage()._content = .tableOfContents(newValue)}
  }

  public var table: Anytype_Model_Block.Content.Table {
    get {
      if case .table(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Table()
    }
    set {_uniqueStorage()._content = .table(newValue)}
  }

  public var tableColumn: Anytype_Model_Block.Content.TableColumn {
    get {
      if case .tableColumn(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.TableColumn()
    }
    set {_uniqueStorage()._content = .tableColumn(newValue)}
  }

  public var tableRow: Anytype_Model_Block.Content.TableRow {
    get {
      if case .tableRow(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.TableRow()
    }
    set {_uniqueStorage()._content = .tableRow(newValue)}
  }

  public var widget: Anytype_Model_Block.Content.Widget {
    get {
      if case .widget(let v)? = _storage._content {return v}
      return Anytype_Model_Block.Content.Widget()
    }
    set {_uniqueStorage()._content = .widget(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case smartblock(Anytype_Model_Block.Content.Smartblock)
    case text(Anytype_Model_Block.Content.Text)
    case file(Anytype_Model_Block.Content.File)
    case layout(Anytype_Model_Block.Content.Layout)
    case div(Anytype_Model_Block.Content.Div)
    case bookmark(Anytype_Model_Block.Content.Bookmark)
    case icon(Anytype_Model_Block.Content.Icon)
    case link(Anytype_Model_Block.Content.Link)
    case dataview(Anytype_Model_Block.Content.Dataview)
    case relation(Anytype_Model_Block.Content.Relation)
    case featuredRelations(Anytype_Model_Block.Content.FeaturedRelations)
    case latex(Anytype_Model_Block.Content.Latex)
    case tableOfContents(Anytype_Model_Block.Content.TableOfContents)
    case table(Anytype_Model_Block.Content.Table)
    case tableColumn(Anytype_Model_Block.Content.TableColumn)
    case tableRow(Anytype_Model_Block.Content.TableRow)
    case widget(Anytype_Model_Block.Content.Widget)

  #if !swift(>=4.1)
    public static func ==(lhs: Anytype_Model_Block.OneOf_Content, rhs: Anytype_Model_Block.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.smartblock, .smartblock): return {
        guard case .smartblock(let l) = lhs, case .smartblock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.layout, .layout): return {
        guard case .layout(let l) = lhs, case .layout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.div, .div): return {
        guard case .div(let l) = lhs, case .div(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bookmark, .bookmark): return {
        guard case .bookmark(let l) = lhs, case .bookmark(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.icon, .icon): return {
        guard case .icon(let l) = lhs, case .icon(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.link, .link): return {
        guard case .link(let l) = lhs, case .link(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataview, .dataview): return {
        guard case .dataview(let l) = lhs, case .dataview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.relation, .relation): return {
        guard case .relation(let l) = lhs, case .relation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.featuredRelations, .featuredRelations): return {
        guard case .featuredRelations(let l) = lhs, case .featuredRelations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.latex, .latex): return {
        guard case .latex(let l) = lhs, case .latex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tableOfContents, .tableOfContents): return {
        guard case .tableOfContents(let l) = lhs, case .tableOfContents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.table, .table): return {
        guard case .table(let l) = lhs, case .table(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tableColumn, .tableColumn): return {
        guard case .tableColumn(let l) = lhs, case .tableColumn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tableRow, .tableRow): return {
        guard case .tableRow(let l) = lhs, case .tableRow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.widget, .widget): return {
        guard case .widget(let l) = lhs, case .widget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Position: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0

    /// above target block
    case top // = 1

    /// under target block
    case bottom // = 2

    /// to left of target block
    case left // = 3

    /// to right of target block
    case right // = 4

    /// inside target block, as last block
    case inner // = 5

    /// replace target block
    case replace // = 6

    /// inside target block, as first block
    case innerFirst // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .top
      case 2: self = .bottom
      case 3: self = .left
      case 4: self = .right
      case 5: self = .inner
      case 6: self = .replace
      case 7: self = .innerFirst
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .top: return 1
      case .bottom: return 2
      case .left: return 3
      case .right: return 4
      case .inner: return 5
      case .replace: return 6
      case .innerFirst: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Align: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case left // = 0
    case center // = 1
    case right // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .left
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .left
      case 1: self = .center
      case 2: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .left: return 0
      case .center: return 1
      case .right: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum VerticalAlign: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case top // = 0
    case middle // = 1
    case bottom // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .top
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .top
      case 1: self = .middle
      case 2: self = .bottom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .top: return 0
      case .middle: return 1
      case .bottom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Restrictions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var read: Bool = false

    public var edit: Bool = false

    public var remove: Bool = false

    public var drag: Bool = false

    public var dropOn: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Content {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Layout have no visual representation, but affects on blocks, that it contains.
    /// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
    public struct Layout {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var style: Anytype_Model_Block.Content.Layout.Style = .row

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Style: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case row // = 0
        case column // = 1
        case div // = 2
        case header // = 3
        case tableRows // = 4
        case tableColumns // = 5
        case UNRECOGNIZED(Int)

        public init() {
          self = .row
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .row
          case 1: self = .column
          case 2: self = .div
          case 3: self = .header
          case 4: self = .tableRows
          case 5: self = .tableColumns
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .row: return 0
          case .column: return 1
          case .div: return 2
          case .header: return 3
          case .tableRows: return 4
          case .tableColumns: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    ///
    /// Link: block to link some content from an external sources.
    public struct Link {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// id of the target block
      public var targetBlockID: String = String()

      /// deprecated
      public var style: Anytype_Model_Block.Content.Link.Style = .page

      public var fields: SwiftProtobuf.Google_Protobuf_Struct {
        get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
        set {_fields = newValue}
      }
      /// Returns true if `fields` has been explicitly set.
      public var hasFields: Bool {return self._fields != nil}
      /// Clears the value of `fields`. Subsequent reads from it will return its default value.
      public mutating func clearFields() {self._fields = nil}

      public var iconSize: Anytype_Model_Block.Content.Link.IconSize = .sizeNone

      public var cardStyle: Anytype_Model_Block.Content.Link.CardStyle = .text

      public var description_p: Anytype_Model_Block.Content.Link.Description = .none

      public var relations: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum IconSize: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case sizeNone // = 0
        case sizeSmall // = 1
        case sizeMedium // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .sizeNone
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .sizeNone
          case 1: self = .sizeSmall
          case 2: self = .sizeMedium
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .sizeNone: return 0
          case .sizeSmall: return 1
          case .sizeMedium: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum Style: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case page // = 0
        case dataview // = 1
        case dashboard // = 2

        /// ...
        case archive // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .page
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .page
          case 1: self = .dataview
          case 2: self = .dashboard
          case 3: self = .archive
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .page: return 0
          case .dataview: return 1
          case .dashboard: return 2
          case .archive: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum Description: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0
        case added // = 1
        case content // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .added
          case 2: self = .content
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .added: return 1
          case .content: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum CardStyle: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case text // = 0
        case card // = 1
        case inline // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .text
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .text
          case 1: self = .card
          case 2: self = .inline
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .text: return 0
          case .card: return 1
          case .inline: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
    }

    ///
    /// Divider: block, that contains only one horizontal thin line
    public struct Div {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var style: Anytype_Model_Block.Content.Div.Style = .line

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Style: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case line // = 0
        case dots // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .line
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .line
          case 1: self = .dots
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .line: return 0
          case .dots: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    ///
    /// Bookmark is to keep a web-link and to preview a content.
    public struct Bookmark {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var url: String = String()

      /// Deprecated. Get this data from the target object.
      public var title: String = String()

      /// Deprecated. Get this data from the target object.
      public var description_p: String = String()

      /// Deprecated. Get this data from the target object.
      public var imageHash: String = String()

      /// Deprecated. Get this data from the target object.
      public var faviconHash: String = String()

      public var type: Anytype_Model_LinkPreview.TypeEnum = .unknown

      public var targetObjectID: String = String()

      public var state: Anytype_Model_Block.Content.Bookmark.State = .empty

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum State: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case empty // = 0
        case fetching // = 1
        case done // = 2
        case error // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .empty
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .empty
          case 1: self = .fetching
          case 2: self = .done
          case 3: self = .error
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .empty: return 0
          case .fetching: return 1
          case .done: return 2
          case .error: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public struct Icon {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct FeaturedRelations {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Text {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var text: String = String()

      public var style: Anytype_Model_Block.Content.Text.Style = .paragraph

      /// list of marks to apply to the text
      public var marks: Anytype_Model_Block.Content.Text.Marks {
        get {return _marks ?? Anytype_Model_Block.Content.Text.Marks()}
        set {_marks = newValue}
      }
      /// Returns true if `marks` has been explicitly set.
      public var hasMarks: Bool {return self._marks != nil}
      /// Clears the value of `marks`. Subsequent reads from it will return its default value.
      public mutating func clearMarks() {self._marks = nil}

      public var checked: Bool = false

      public var color: String = String()

      /// used with style Callout
      public var iconEmoji: String = String()

      /// in case both image and emoji are set, image should has a priority in the UI
      public var iconImage: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Style: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case paragraph // = 0
        case header1 // = 1
        case header2 // = 2
        case header3 // = 3

        /// deprecated
        case header4 // = 4
        case quote // = 5
        case code // = 6

        /// currently only one block of this style can exists on a page
        case title // = 7
        case checkbox // = 8
        case marked // = 9
        case numbered // = 10
        case toggle // = 11

        /// currently only one block of this style can exists on a page
        case description_ // = 12
        case callout // = 13
        case UNRECOGNIZED(Int)

        public init() {
          self = .paragraph
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .paragraph
          case 1: self = .header1
          case 2: self = .header2
          case 3: self = .header3
          case 4: self = .header4
          case 5: self = .quote
          case 6: self = .code
          case 7: self = .title
          case 8: self = .checkbox
          case 9: self = .marked
          case 10: self = .numbered
          case 11: self = .toggle
          case 12: self = .description_
          case 13: self = .callout
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .paragraph: return 0
          case .header1: return 1
          case .header2: return 2
          case .header3: return 3
          case .header4: return 4
          case .quote: return 5
          case .code: return 6
          case .title: return 7
          case .checkbox: return 8
          case .marked: return 9
          case .numbered: return 10
          case .toggle: return 11
          case .description_: return 12
          case .callout: return 13
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public struct Marks {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var marks: [Anytype_Model_Block.Content.Text.Mark] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Mark {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// range of symbols to apply this mark. From(symbol) To(symbol)
        public var range: Anytype_Model_Range {
          get {return _range ?? Anytype_Model_Range()}
          set {_range = newValue}
        }
        /// Returns true if `range` has been explicitly set.
        public var hasRange: Bool {return self._range != nil}
        /// Clears the value of `range`. Subsequent reads from it will return its default value.
        public mutating func clearRange() {self._range = nil}

        public var type: Anytype_Model_Block.Content.Text.Mark.TypeEnum = .strikethrough

        /// link, color, etc
        public var param: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case strikethrough // = 0
          case keyboard // = 1
          case italic // = 2
          case bold // = 3
          case underscored // = 4
          case link // = 5
          case textColor // = 6
          case backgroundColor // = 7
          case mention // = 8
          case emoji // = 9
          case object // = 10
          case UNRECOGNIZED(Int)

          public init() {
            self = .strikethrough
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .strikethrough
            case 1: self = .keyboard
            case 2: self = .italic
            case 3: self = .bold
            case 4: self = .underscored
            case 5: self = .link
            case 6: self = .textColor
            case 7: self = .backgroundColor
            case 8: self = .mention
            case 9: self = .emoji
            case 10: self = .object
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .strikethrough: return 0
            case .keyboard: return 1
            case .italic: return 2
            case .bold: return 3
            case .underscored: return 4
            case .link: return 5
            case .textColor: return 6
            case .backgroundColor: return 7
            case .mention: return 8
            case .emoji: return 9
            case .object: return 10
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}

        fileprivate var _range: Anytype_Model_Range? = nil
      }

      public init() {}

      fileprivate var _marks: Anytype_Model_Block.Content.Text.Marks? = nil
    }

    public struct File {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var hash: String = String()

      public var name: String = String()

      public var type: Anytype_Model_Block.Content.File.TypeEnum = .none

      public var mime: String = String()

      public var size: Int64 = 0

      public var addedAt: Int64 = 0

      public var targetObjectID: String = String()

      public var state: Anytype_Model_Block.Content.File.State = .empty

      public var style: Anytype_Model_Block.Content.File.Style = .auto

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum TypeEnum: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0
        case file // = 1
        case image // = 2
        case video // = 3
        case audio // = 4
        case pdf // = 5
        case UNRECOGNIZED(Int)

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .file
          case 2: self = .image
          case 3: self = .video
          case 4: self = .audio
          case 5: self = .pdf
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .file: return 1
          case .image: return 2
          case .video: return 3
          case .audio: return 4
          case .pdf: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum Style: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// all types expect File and None has Embed style by default
        case auto // = 0
        case link // = 1
        case embed // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .auto
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .auto
          case 1: self = .link
          case 2: self = .embed
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .auto: return 0
          case .link: return 1
          case .embed: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum State: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// There is no file and preview, it's an empty block, that waits files.
        case empty // = 0

        /// There is still no file/preview, but file already uploading
        case uploading // = 1

        /// File and preview downloaded
        case done // = 2

        /// Error while uploading
        case error // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .empty
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .empty
          case 1: self = .uploading
          case 2: self = .done
          case 3: self = .error
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .empty: return 0
          case .uploading: return 1
          case .done: return 2
          case .error: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public struct Smartblock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Dataview {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var source: [String] = []

      public var views: [Anytype_Model_Block.Content.Dataview.View] = []

      /// deprecated
      public var relations: [Anytype_Model_Relation] = []

      /// saved within a session
      public var activeView: String = String()

      public var groupOrders: [Anytype_Model_Block.Content.Dataview.GroupOrder] = []

      public var objectOrders: [Anytype_Model_Block.Content.Dataview.ObjectOrder] = []

      public var relationLinks: [Anytype_Model_RelationLink] = []

      public var targetObjectID: String = String()

      public var isCollection: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct View {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var type: Anytype_Model_Block.Content.Dataview.View.TypeEnum = .table

        public var name: String = String()

        public var sorts: [Anytype_Model_Block.Content.Dataview.Sort] = []

        public var filters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        /// relations fields/columns options, also used to provide the order
        public var relations: [Anytype_Model_Block.Content.Dataview.Relation] = []

        /// Relation used for cover in gallery
        public var coverRelationKey: String = String()

        /// Hide icon near name
        public var hideIcon: Bool = false

        /// Gallery card size
        public var cardSize: Anytype_Model_Block.Content.Dataview.View.Size = .small

        /// Image fits container
        public var coverFit: Bool = false

        /// Group view by this relationKey
        public var groupRelationKey: String = String()

        /// Enable backgrounds in groups
        public var groupBackgroundColors: Bool = false

        /// Limit of objects shown in widget
        public var pageLimit: Int32 = 0

        /// Default template that is chosen for new object created within the view
        public var defaultTemplateID: String = String()

        /// Default object type that is chosen for new object created within the view
        public var defaultObjectTypeID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case table // = 0
          case list // = 1
          case gallery // = 2
          case kanban // = 3
          case calendar // = 4
          case graph // = 5
          case UNRECOGNIZED(Int)

          public init() {
            self = .table
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .table
            case 1: self = .list
            case 2: self = .gallery
            case 3: self = .kanban
            case 4: self = .calendar
            case 5: self = .graph
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .table: return 0
            case .list: return 1
            case .gallery: return 2
            case .kanban: return 3
            case .calendar: return 4
            case .graph: return 5
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum Size: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case small // = 0
          case medium // = 1
          case large // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .small
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .small
            case 1: self = .medium
            case 2: self = .large
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .small: return 0
            case .medium: return 1
            case .large: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Relation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var key: String = String()

        public var isVisible: Bool = false

        /// the displayed column % calculated based on other visible relations
        public var width: Int32 = 0

        public var dateIncludeTime: Bool = false

        public var timeFormat: Anytype_Model_Block.Content.Dataview.Relation.TimeFormat = .format12

        public var dateFormat: Anytype_Model_Block.Content.Dataview.Relation.DateFormat = .monthAbbrBeforeDay

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum DateFormat: SwiftProtobuf.Enum {
          public typealias RawValue = Int

          /// Jul 30, 2020
          case monthAbbrBeforeDay // = 0

          /// 30 Jul 2020
          case monthAbbrAfterDay // = 1

          /// 30/07/2020
          case short // = 2

          /// 07/30/2020
          case shortUs // = 3

          /// 2020-07-30
          case iso // = 4
          case UNRECOGNIZED(Int)

          public init() {
            self = .monthAbbrBeforeDay
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .monthAbbrBeforeDay
            case 1: self = .monthAbbrAfterDay
            case 2: self = .short
            case 3: self = .shortUs
            case 4: self = .iso
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .monthAbbrBeforeDay: return 0
            case .monthAbbrAfterDay: return 1
            case .short: return 2
            case .shortUs: return 3
            case .iso: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum TimeFormat: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case format12 // = 0
          case format24 // = 1
          case UNRECOGNIZED(Int)

          public init() {
            self = .format12
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .format12
            case 1: self = .format24
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .format12: return 0
            case .format24: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Sort {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var relationKey: String = String()

        public var type: Anytype_Model_Block.Content.Dataview.Sort.TypeEnum = .asc

        public var customOrder: [SwiftProtobuf.Google_Protobuf_Value] = []

        public var format: Anytype_Model_RelationFormat = .longtext

        public var includeTime: Bool = false

        public var id: String = String()

        public var emptyPlacement: Anytype_Model_Block.Content.Dataview.Sort.EmptyType = .notSpecified

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case asc // = 0
          case desc // = 1
          case custom // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .asc
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .asc
            case 1: self = .desc
            case 2: self = .custom
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .asc: return 0
            case .desc: return 1
            case .custom: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum EmptyType: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case notSpecified // = 0
          case start // = 1
          case end // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .notSpecified
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .notSpecified
            case 1: self = .start
            case 2: self = .end
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .notSpecified: return 0
            case .start: return 1
            case .end: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Filter {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        /// looks not applicable?
        public var `operator`: Anytype_Model_Block.Content.Dataview.Filter.Operator = .and

        public var relationKey: String = String()

        public var relationProperty: String = String()

        public var condition: Anytype_Model_Block.Content.Dataview.Filter.Condition = .none

        public var value: SwiftProtobuf.Google_Protobuf_Value {
          get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
          set {_value = newValue}
        }
        /// Returns true if `value` has been explicitly set.
        public var hasValue: Bool {return self._value != nil}
        /// Clears the value of `value`. Subsequent reads from it will return its default value.
        public mutating func clearValue() {self._value = nil}

        public var quickOption: Anytype_Model_Block.Content.Dataview.Filter.QuickOption = .exactDate

        public var format: Anytype_Model_RelationFormat = .longtext

        public var includeTime: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Operator: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case and // = 0
          case or // = 1
          case UNRECOGNIZED(Int)

          public init() {
            self = .and
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .and
            case 1: self = .or
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .and: return 0
            case .or: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum Condition: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case none // = 0
          case equal // = 1
          case notEqual // = 2
          case greater // = 3
          case less // = 4
          case greaterOrEqual // = 5
          case lessOrEqual // = 6
          case like // = 7
          case notLike // = 8

          /// "at least one value(from the provided list) is IN"
          case `in` // = 9

          /// "none of provided values are IN"
          case notIn // = 10
          case empty // = 11
          case notEmpty // = 12
          case allIn // = 13
          case notAllIn // = 14
          case exactIn // = 15
          case notExactIn // = 16
          case exists // = 17
          case UNRECOGNIZED(Int)

          public init() {
            self = .none
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .equal
            case 2: self = .notEqual
            case 3: self = .greater
            case 4: self = .less
            case 5: self = .greaterOrEqual
            case 6: self = .lessOrEqual
            case 7: self = .like
            case 8: self = .notLike
            case 9: self = .in
            case 10: self = .notIn
            case 11: self = .empty
            case 12: self = .notEmpty
            case 13: self = .allIn
            case 14: self = .notAllIn
            case 15: self = .exactIn
            case 16: self = .notExactIn
            case 17: self = .exists
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .none: return 0
            case .equal: return 1
            case .notEqual: return 2
            case .greater: return 3
            case .less: return 4
            case .greaterOrEqual: return 5
            case .lessOrEqual: return 6
            case .like: return 7
            case .notLike: return 8
            case .in: return 9
            case .notIn: return 10
            case .empty: return 11
            case .notEmpty: return 12
            case .allIn: return 13
            case .notAllIn: return 14
            case .exactIn: return 15
            case .notExactIn: return 16
            case .exists: return 17
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum QuickOption: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case exactDate // = 0
          case yesterday // = 1
          case today // = 2
          case tomorrow // = 3
          case lastWeek // = 4
          case currentWeek // = 5
          case nextWeek // = 6
          case lastMonth // = 7
          case currentMonth // = 8
          case nextMonth // = 9
          case numberOfDaysAgo // = 10
          case numberOfDaysNow // = 11
          case UNRECOGNIZED(Int)

          public init() {
            self = .exactDate
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .exactDate
            case 1: self = .yesterday
            case 2: self = .today
            case 3: self = .tomorrow
            case 4: self = .lastWeek
            case 5: self = .currentWeek
            case 6: self = .nextWeek
            case 7: self = .lastMonth
            case 8: self = .currentMonth
            case 9: self = .nextMonth
            case 10: self = .numberOfDaysAgo
            case 11: self = .numberOfDaysNow
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .exactDate: return 0
            case .yesterday: return 1
            case .today: return 2
            case .tomorrow: return 3
            case .lastWeek: return 4
            case .currentWeek: return 5
            case .nextWeek: return 6
            case .lastMonth: return 7
            case .currentMonth: return 8
            case .nextMonth: return 9
            case .numberOfDaysAgo: return 10
            case .numberOfDaysNow: return 11
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}

        fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
      }

      public struct GroupOrder {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var viewID: String = String()

        public var viewGroups: [Anytype_Model_Block.Content.Dataview.ViewGroup] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct ViewGroup {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var groupID: String = String()

        public var index: Int32 = 0

        public var hidden: Bool = false

        public var backgroundColor: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct ObjectOrder {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var viewID: String = String()

        public var groupID: String = String()

        public var objectIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Group {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var value: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value? = nil

        public var status: Anytype_Model_Block.Content.Dataview.Status {
          get {
            if case .status(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Status()
          }
          set {value = .status(newValue)}
        }

        public var tag: Anytype_Model_Block.Content.Dataview.Tag {
          get {
            if case .tag(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Tag()
          }
          set {value = .tag(newValue)}
        }

        public var checkbox: Anytype_Model_Block.Content.Dataview.Checkbox {
          get {
            if case .checkbox(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Checkbox()
          }
          set {value = .checkbox(newValue)}
        }

        public var date: Anytype_Model_Block.Content.Dataview.Date {
          get {
            if case .date(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Date()
          }
          set {value = .date(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Value: Equatable {
          case status(Anytype_Model_Block.Content.Dataview.Status)
          case tag(Anytype_Model_Block.Content.Dataview.Tag)
          case checkbox(Anytype_Model_Block.Content.Dataview.Checkbox)
          case date(Anytype_Model_Block.Content.Dataview.Date)

        #if !swift(>=4.1)
          public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value, rhs: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.status, .status): return {
              guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.tag, .tag): return {
              guard case .tag(let l) = lhs, case .tag(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.checkbox, .checkbox): return {
              guard case .checkbox(let l) = lhs, case .checkbox(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.date, .date): return {
              guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            default: return false
            }
          }
        #endif
        }

        public init() {}
      }

      public struct Status {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Tag {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var ids: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Checkbox {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var checked: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Date {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct Relation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var key: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Latex {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var text: String = String()

      public var processor: Anytype_Model_Block.Content.Latex.Processor = .latex

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Processor: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case latex // = 0
        case mermaid // = 1
        case chart // = 2
        case youtube // = 3
        case vimeo // = 4
        case soundcloud // = 5
        case googleMaps // = 6
        case miro // = 7
        case figma // = 8
        case twitter // = 9
        case openStreetMap // = 10
        case reddit // = 11
        case facebook // = 12
        case instagram // = 13
        case telegram // = 14
        case githubGist // = 15
        case codepen // = 16
        case bilibili // = 17
        case excalidraw // = 18
        case UNRECOGNIZED(Int)

        public init() {
          self = .latex
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .latex
          case 1: self = .mermaid
          case 2: self = .chart
          case 3: self = .youtube
          case 4: self = .vimeo
          case 5: self = .soundcloud
          case 6: self = .googleMaps
          case 7: self = .miro
          case 8: self = .figma
          case 9: self = .twitter
          case 10: self = .openStreetMap
          case 11: self = .reddit
          case 12: self = .facebook
          case 13: self = .instagram
          case 14: self = .telegram
          case 15: self = .githubGist
          case 16: self = .codepen
          case 17: self = .bilibili
          case 18: self = .excalidraw
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .latex: return 0
          case .mermaid: return 1
          case .chart: return 2
          case .youtube: return 3
          case .vimeo: return 4
          case .soundcloud: return 5
          case .googleMaps: return 6
          case .miro: return 7
          case .figma: return 8
          case .twitter: return 9
          case .openStreetMap: return 10
          case .reddit: return 11
          case .facebook: return 12
          case .instagram: return 13
          case .telegram: return 14
          case .githubGist: return 15
          case .codepen: return 16
          case .bilibili: return 17
          case .excalidraw: return 18
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public struct TableOfContents {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Table {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct TableColumn {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct TableRow {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var isHeader: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Widget {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var layout: Anytype_Model_Block.Content.Widget.Layout = .link

      public var limit: Int32 = 0

      public var viewID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Layout: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case link // = 0
        case tree // = 1
        case list // = 2
        case compactList // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .link
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .link
          case 1: self = .tree
          case 2: self = .list
          case 3: self = .compactList
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .link: return 0
          case .tree: return 1
          case .list: return 2
          case .compactList: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Anytype_Model_Block.Position: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Position] = [
    .none,
    .top,
    .bottom,
    .left,
    .right,
    .inner,
    .replace,
    .innerFirst,
  ]
}

extension Anytype_Model_Block.Align: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Align] = [
    .left,
    .center,
    .right,
  ]
}

extension Anytype_Model_Block.VerticalAlign: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.VerticalAlign] = [
    .top,
    .middle,
    .bottom,
  ]
}

extension Anytype_Model_Block.Content.Layout.Style: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Layout.Style] = [
    .row,
    .column,
    .div,
    .header,
    .tableRows,
    .tableColumns,
  ]
}

extension Anytype_Model_Block.Content.Link.IconSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Link.IconSize] = [
    .sizeNone,
    .sizeSmall,
    .sizeMedium,
  ]
}

extension Anytype_Model_Block.Content.Link.Style: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Link.Style] = [
    .page,
    .dataview,
    .dashboard,
    .archive,
  ]
}

extension Anytype_Model_Block.Content.Link.Description: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Link.Description] = [
    .none,
    .added,
    .content,
  ]
}

extension Anytype_Model_Block.Content.Link.CardStyle: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Link.CardStyle] = [
    .text,
    .card,
    .inline,
  ]
}

extension Anytype_Model_Block.Content.Div.Style: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Div.Style] = [
    .line,
    .dots,
  ]
}

extension Anytype_Model_Block.Content.Bookmark.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Bookmark.State] = [
    .empty,
    .fetching,
    .done,
    .error,
  ]
}

extension Anytype_Model_Block.Content.Text.Style: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Text.Style] = [
    .paragraph,
    .header1,
    .header2,
    .header3,
    .header4,
    .quote,
    .code,
    .title,
    .checkbox,
    .marked,
    .numbered,
    .toggle,
    .description_,
    .callout,
  ]
}

extension Anytype_Model_Block.Content.Text.Mark.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Text.Mark.TypeEnum] = [
    .strikethrough,
    .keyboard,
    .italic,
    .bold,
    .underscored,
    .link,
    .textColor,
    .backgroundColor,
    .mention,
    .emoji,
    .object,
  ]
}

extension Anytype_Model_Block.Content.File.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.File.TypeEnum] = [
    .none,
    .file,
    .image,
    .video,
    .audio,
    .pdf,
  ]
}

extension Anytype_Model_Block.Content.File.Style: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.File.Style] = [
    .auto,
    .link,
    .embed,
  ]
}

extension Anytype_Model_Block.Content.File.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.File.State] = [
    .empty,
    .uploading,
    .done,
    .error,
  ]
}

extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.View.TypeEnum] = [
    .table,
    .list,
    .gallery,
    .kanban,
    .calendar,
    .graph,
  ]
}

extension Anytype_Model_Block.Content.Dataview.View.Size: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.View.Size] = [
    .small,
    .medium,
    .large,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Relation.DateFormat] = [
    .monthAbbrBeforeDay,
    .monthAbbrAfterDay,
    .short,
    .shortUs,
    .iso,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Relation.TimeFormat] = [
    .format12,
    .format24,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Sort.TypeEnum] = [
    .asc,
    .desc,
    .custom,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Sort.EmptyType] = [
    .notSpecified,
    .start,
    .end,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.Operator] = [
    .and,
    .or,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Condition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.Condition] = [
    .none,
    .equal,
    .notEqual,
    .greater,
    .less,
    .greaterOrEqual,
    .lessOrEqual,
    .like,
    .notLike,
    .in,
    .notIn,
    .empty,
    .notEmpty,
    .allIn,
    .notAllIn,
    .exactIn,
    .notExactIn,
    .exists,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Dataview.Filter.QuickOption] = [
    .exactDate,
    .yesterday,
    .today,
    .tomorrow,
    .lastWeek,
    .currentWeek,
    .nextWeek,
    .lastMonth,
    .currentMonth,
    .nextMonth,
    .numberOfDaysAgo,
    .numberOfDaysNow,
  ]
}

extension Anytype_Model_Block.Content.Latex.Processor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Latex.Processor] = [
    .latex,
    .mermaid,
    .chart,
    .youtube,
    .vimeo,
    .soundcloud,
    .googleMaps,
    .miro,
    .figma,
    .twitter,
    .openStreetMap,
    .reddit,
    .facebook,
    .instagram,
    .telegram,
    .githubGist,
    .codepen,
    .bilibili,
    .excalidraw,
  ]
}

extension Anytype_Model_Block.Content.Widget.Layout: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Block.Content.Widget.Layout] = [
    .link,
    .tree,
    .list,
    .compactList,
  ]
}

#endif  // swift(>=4.2)

///
/// Used to decode block meta only, without the content itself
public struct Anytype_Model_BlockMetaOnly {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var fields: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {self._fields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

///
/// General purpose structure, uses in Mark.
public struct Anytype_Model_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Int32 = 0

  public var to: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Contains basic information about a user account
public struct Anytype_Model_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User's thread id
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User name, that associated with this account
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Avatar of a user's account
  public var avatar: Anytype_Model_Account.Avatar {
    get {return _storage._avatar ?? Anytype_Model_Account.Avatar()}
    set {_uniqueStorage()._avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  public var hasAvatar: Bool {return _storage._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  public mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

  public var config: Anytype_Model_Account.Config {
    get {return _storage._config ?? Anytype_Model_Account.Config()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  public var status: Anytype_Model_Account.Status {
    get {return _storage._status ?? Anytype_Model_Account.Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var info: Anytype_Model_Account.Info {
    get {return _storage._info ?? Anytype_Model_Account.Info()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum StatusType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case active // = 0
    case pendingDeletion // = 1
    case startedDeletion // = 2
    case deleted // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .pendingDeletion
      case 2: self = .startedDeletion
      case 3: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .pendingDeletion: return 1
      case .startedDeletion: return 2
      case .deleted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///*
  /// Avatar of a user's account. It could be an image or color
  public struct Avatar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var avatar: Anytype_Model_Account.Avatar.OneOf_Avatar? = nil

    /// Image of the avatar. Contains the hash to retrieve the image.
    public var image: Anytype_Model_Block.Content.File {
      get {
        if case .image(let v)? = avatar {return v}
        return Anytype_Model_Block.Content.File()
      }
      set {avatar = .image(newValue)}
    }

    /// Color of the avatar, used if image not set.
    public var color: String {
      get {
        if case .color(let v)? = avatar {return v}
        return String()
      }
      set {avatar = .color(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Avatar: Equatable {
      /// Image of the avatar. Contains the hash to retrieve the image.
      case image(Anytype_Model_Block.Content.File)
      /// Color of the avatar, used if image not set.
      case color(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Anytype_Model_Account.Avatar.OneOf_Avatar, rhs: Anytype_Model_Account.Avatar.OneOf_Avatar) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.image, .image): return {
          guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.color, .color): return {
          guard case .color(let l) = lhs, case .color(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct Config {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var enableDataview: Bool = false

    public var enableDebug: Bool = false

    public var enablePrereleaseChannel: Bool = false

    public var enableSpaces: Bool = false

    public var extra: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _extra ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_extra = newValue}
    }
    /// Returns true if `extra` has been explicitly set.
    public var hasExtra: Bool {return self._extra != nil}
    /// Clears the value of `extra`. Subsequent reads from it will return its default value.
    public mutating func clearExtra() {self._extra = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _extra: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public struct Status {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var statusType: Anytype_Model_Account.StatusType = .active

    public var deletionDate: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Info {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// home dashboard block id
    public var homeObjectID: String = String()

    /// archive block id
    public var archiveObjectID: String = String()

    /// profile block id
    public var profileObjectID: String = String()

    /// marketplace workspace id
    public var marketplaceWorkspaceID: String = String()

    public var deviceID: String = String()

    public var accountSpaceID: String = String()

    public var widgetsID: String = String()

    public var spaceViewID: String = String()

    public var techSpaceID: String = String()

    /// gateway url for fetching static files
    public var gatewayURL: String = String()

    /// path to local storage
    public var localStoragePath: String = String()

    /// time zone from config
    public var timeZone: String = String()

    public var analyticsID: String = String()

    /// network id to which anytype is connected
    public var networkID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Anytype_Model_Account.StatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Account.StatusType] = [
    .active,
    .pendingDeletion,
    .startedDeletion,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var imageURL: String = String()

  public var faviconURL: String = String()

  public var type: Anytype_Model_LinkPreview.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case page // = 1
    case image // = 2
    case text // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .page
      case 2: self = .image
      case 3: self = .text
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .page: return 1
      case .image: return 2
      case .text: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_LinkPreview.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_LinkPreview.TypeEnum] = [
    .unknown,
    .page,
    .image,
    .text,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Restrictions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var object: [Anytype_Model_Restrictions.ObjectRestriction] = []

  public var dataview: [Anytype_Model_Restrictions.DataviewRestrictions] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ObjectRestriction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0

    /// restricts delete
    case delete // = 1

    /// restricts work with relations
    case relations // = 2

    /// restricts work with blocks
    case blocks // = 3

    /// restricts work with details
    case details // = 4

    /// restricts type changing
    case typeChange // = 5

    /// restricts layout changing
    case layoutChange // = 6

    /// restricts template creation from this object
    case template // = 7

    /// restricts duplicate object
    case duplicate // = 8

    /// can be set only for types. Restricts creating objects of this type
    case createObjectOfThisType // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .delete
      case 2: self = .relations
      case 3: self = .blocks
      case 4: self = .details
      case 5: self = .typeChange
      case 6: self = .layoutChange
      case 7: self = .template
      case 8: self = .duplicate
      case 9: self = .createObjectOfThisType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .delete: return 1
      case .relations: return 2
      case .blocks: return 3
      case .details: return 4
      case .typeChange: return 5
      case .layoutChange: return 6
      case .template: return 7
      case .duplicate: return 8
      case .createObjectOfThisType: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum DataviewRestriction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case dvnone // = 0
    case dvrelation // = 1
    case dvcreateObject // = 2
    case dvviews // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .dvnone
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dvnone
      case 1: self = .dvrelation
      case 2: self = .dvcreateObject
      case 3: self = .dvviews
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dvnone: return 0
      case .dvrelation: return 1
      case .dvcreateObject: return 2
      case .dvviews: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct DataviewRestrictions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var blockID: String = String()

    public var restrictions: [Anytype_Model_Restrictions.DataviewRestriction] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_Restrictions.ObjectRestriction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Restrictions.ObjectRestriction] = [
    .none,
    .delete,
    .relations,
    .blocks,
    .details,
    .typeChange,
    .layoutChange,
    .template,
    .duplicate,
    .createObjectOfThisType,
  ]
}

extension Anytype_Model_Restrictions.DataviewRestriction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Restrictions.DataviewRestriction] = [
    .dvnone,
    .dvrelation,
    .dvcreateObject,
    .dvviews,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Object {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ChangePayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var smartBlockType: Anytype_Model_SmartBlockType = .accountOld

    public var key: String = String()

    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Anytype_Model_SpaceObjectHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spaceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_ObjectType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// leave empty in case you want to create the new one
  public var url: String = String()

  /// name of objectType (can be localized for bundled types)
  public var name: String = String()

  /// cannot contain more than one Relation with the same RelationType
  public var relationLinks: [Anytype_Model_RelationLink] = []

  public var layout: Anytype_Model_ObjectType.Layout = .basic

  /// emoji symbol
  public var iconEmoji: String = String()

  public var description_p: String = String()

  public var hidden: Bool = false

  public var readonly: Bool = false

  public var types: [Anytype_Model_SmartBlockType] = []

  /// sets locally to hide object type from set and some other places
  public var isArchived: Bool = false

  public var installedByDefault: Bool = false

  /// name of objectType (can be localized for bundled types)
  public var key: String = String()

  /// revision of system objectType. Used to check if we should change type content or not
  public var revision: Int64 = 0

  /// restricts creating objects of this type for users
  public var restrictObjectCreation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Layout: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case basic // = 0
    case profile // = 1
    case todo // = 2
    case set // = 3
    case objectType // = 4
    case relation // = 5
    case file // = 6
    case dashboard // = 7
    case image // = 8
    case note // = 9
    case space // = 10
    case bookmark // = 11
    case relationOptionsList // = 12
    case relationOption // = 13
    case collection // = 14
    case audio // = 15
    case video // = 16
    case date // = 17
    case spaceView // = 18
    case participant // = 19
    case pdf // = 20
    case UNRECOGNIZED(Int)

    public init() {
      self = .basic
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .basic
      case 1: self = .profile
      case 2: self = .todo
      case 3: self = .set
      case 4: self = .objectType
      case 5: self = .relation
      case 6: self = .file
      case 7: self = .dashboard
      case 8: self = .image
      case 9: self = .note
      case 10: self = .space
      case 11: self = .bookmark
      case 12: self = .relationOptionsList
      case 13: self = .relationOption
      case 14: self = .collection
      case 15: self = .audio
      case 16: self = .video
      case 17: self = .date
      case 18: self = .spaceView
      case 19: self = .participant
      case 20: self = .pdf
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .basic: return 0
      case .profile: return 1
      case .todo: return 2
      case .set: return 3
      case .objectType: return 4
      case .relation: return 5
      case .file: return 6
      case .dashboard: return 7
      case .image: return 8
      case .note: return 9
      case .space: return 10
      case .bookmark: return 11
      case .relationOptionsList: return 12
      case .relationOption: return 13
      case .collection: return 14
      case .audio: return 15
      case .video: return 16
      case .date: return 17
      case .spaceView: return 18
      case .participant: return 19
      case .pdf: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_ObjectType.Layout: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_ObjectType.Layout] = [
    .basic,
    .profile,
    .todo,
    .set,
    .objectType,
    .relation,
    .file,
    .dashboard,
    .image,
    .note,
    .space,
    .bookmark,
    .relationOptionsList,
    .relationOption,
    .collection,
    .audio,
    .video,
    .date,
    .spaceView,
    .participant,
    .pdf,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Layout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Anytype_Model_ObjectType.Layout = .basic

  public var name: String = String()

  /// relations required for this object type
  public var requiredRelations: [Anytype_Model_Relation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_RelationWithValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var relation: Anytype_Model_Relation {
    get {return _relation ?? Anytype_Model_Relation()}
    set {_relation = newValue}
  }
  /// Returns true if `relation` has been explicitly set.
  public var hasRelation: Bool {return self._relation != nil}
  /// Clears the value of `relation`. Subsequent reads from it will return its default value.
  public mutating func clearRelation() {self._relation = nil}

  public var value: SwiftProtobuf.Google_Protobuf_Value {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _relation: Anytype_Model_Relation? = nil
  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
}

/// Relation describe the human-interpreted relation type. It may be something like "Date of creation, format=date" or "Assignee, format=objectId, objectType=person"
public struct Anytype_Model_Relation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Key under which the value is stored in the map. Must be unique for the object type.
  /// It usually auto-generated bsonid, but also may be something human-readable in case of prebuilt types.
  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// format of the underlying data
  public var format: Anytype_Model_RelationFormat {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  /// name to show (can be localized for bundled types)
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var defaultValue: SwiftProtobuf.Google_Protobuf_Value {
    get {return _storage._defaultValue ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_uniqueStorage()._defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return _storage._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {_uniqueStorage()._defaultValue = nil}

  /// where the data is stored
  public var dataSource: Anytype_Model_Relation.DataSource {
    get {return _storage._dataSource}
    set {_uniqueStorage()._dataSource = newValue}
  }

  /// internal, not displayed to user (e.g. coverX, coverY)
  public var hidden: Bool {
    get {return _storage._hidden}
    set {_uniqueStorage()._hidden = newValue}
  }

  /// value not editable by user tobe renamed to readonlyValue
  public var readOnly: Bool {
    get {return _storage._readOnly}
    set {_uniqueStorage()._readOnly = newValue}
  }

  /// relation metadata, eg name and format is not editable by user
  public var readOnlyRelation: Bool {
    get {return _storage._readOnlyRelation}
    set {_uniqueStorage()._readOnlyRelation = newValue}
  }

  /// allow multiple values (stored in pb list)
  public var multi: Bool {
    get {return _storage._multi}
    set {_uniqueStorage()._multi = newValue}
  }

  /// URL of object type, empty to allow link to any object
  public var objectTypes: [String] {
    get {return _storage._objectTypes}
    set {_uniqueStorage()._objectTypes = newValue}
  }

  /// index 10, 11 was used in internal-only builds. Can be reused, but may break some test accounts
  public var selectDict: [Anytype_Model_Relation.Option] {
    get {return _storage._selectDict}
    set {_uniqueStorage()._selectDict = newValue}
  }

  /// max number of values can be set for this relation. 0 means no limit. 1 means the value can be stored in non-repeated field
  public var maxCount: Int32 {
    get {return _storage._maxCount}
    set {_uniqueStorage()._maxCount = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// on-store fields, injected only locally
  public var scope: Anytype_Model_Relation.Scope {
    get {return _storage._scope}
    set {_uniqueStorage()._scope = newValue}
  }

  /// creator profile id
  public var creator: String {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  /// revision of system relation. Used to check if we should change relation content or not
  public var revision: Int64 {
    get {return _storage._revision}
    set {_uniqueStorage()._revision = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Scope: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// stored within the object
    case object // = 0

    /// stored within the object type
    case type // = 1

    /// aggregated from the dataview of sets of the same object type
    case setOfTheSameType // = 2

    /// aggregated from the dataview of sets of the same object type
    case objectsOfTheSameType // = 3

    /// aggregated from relations library
    case library // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .object
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .object
      case 1: self = .type
      case 2: self = .setOfTheSameType
      case 3: self = .objectsOfTheSameType
      case 4: self = .library
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .object: return 0
      case .type: return 1
      case .setOfTheSameType: return 2
      case .objectsOfTheSameType: return 3
      case .library: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum DataSource: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// default, stored inside the object's details
    case details // = 0

    /// stored locally, e.g. in badger or generated on the fly
    case derived // = 1

    /// stored in the account DB. means existing only for specific anytype account
    case account // = 2

    /// stored locally
    case local // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .details
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .details
      case 1: self = .derived
      case 2: self = .account
      case 3: self = .local
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .details: return 0
      case .derived: return 1
      case .account: return 2
      case .local: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// id generated automatically if omitted
    public var id: String = String()

    public var text: String = String()

    /// stored
    public var color: String = String()

    /// 4 is reserved for old relation format
    public var relationKey: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Anytype_Model_Relation.Scope: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Relation.Scope] = [
    .object,
    .type,
    .setOfTheSameType,
    .objectsOfTheSameType,
    .library,
  ]
}

extension Anytype_Model_Relation.DataSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Relation.DataSource] = [
    .details,
    .derived,
    .account,
    .local,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_RelationLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var format: Anytype_Model_RelationFormat = .longtext

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_Relations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var relations: [Anytype_Model_Relation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_RelationOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: [Anytype_Model_Relation.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_InternalFlag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Anytype_Model_InternalFlag.Value = .editorDeleteEmpty

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Use such a weird construction due to the issue with imported repeated enum type
  /// Look https://github.com/golang/protobuf/issues/1135 for more information.
  public enum Value: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case editorDeleteEmpty // = 0
    case editorSelectType // = 1
    case editorSelectTemplate // = 2
    case collectionDontIndexLinks // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .editorDeleteEmpty
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .editorDeleteEmpty
      case 1: self = .editorSelectType
      case 2: self = .editorSelectTemplate
      case 3: self = .collectionDontIndexLinks
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .editorDeleteEmpty: return 0
      case .editorSelectType: return 1
      case .editorSelectTemplate: return 2
      case .collectionDontIndexLinks: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_InternalFlag.Value: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_InternalFlag.Value] = [
    .editorDeleteEmpty,
    .editorSelectType,
    .editorSelectTemplate,
    .collectionDontIndexLinks,
  ]
}

#endif  // swift(>=4.2)

///
/// Works with a smart blocks: Page, Dashboard
/// Dashboard opened, click on a page, Rpc.Block.open, Block.ShowFullscreen(PageBlock)
public struct Anytype_Model_ObjectView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Root block id
  public var rootID: String = String()

  /// dependent simple blocks (descendants)
  public var blocks: [Anytype_Model_Block] = []

  /// details for the current and dependent objects
  public var details: [Anytype_Model_ObjectView.DetailsSet] = []

  public var type: Anytype_Model_SmartBlockType = .accountOld

  /// DEPRECATED, use relationLinks instead
  public var relations: [Anytype_Model_Relation] = []

  public var relationLinks: [Anytype_Model_RelationLink] = []

  /// object restrictions
  public var restrictions: Anytype_Model_Restrictions {
    get {return _restrictions ?? Anytype_Model_Restrictions()}
    set {_restrictions = newValue}
  }
  /// Returns true if `restrictions` has been explicitly set.
  public var hasRestrictions: Bool {return self._restrictions != nil}
  /// Clears the value of `restrictions`. Subsequent reads from it will return its default value.
  public mutating func clearRestrictions() {self._restrictions = nil}

  public var history: Anytype_Model_ObjectView.HistorySize {
    get {return _history ?? Anytype_Model_ObjectView.HistorySize()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  public var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  public mutating func clearHistory() {self._history = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DetailsSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// context objectId
    public var id: String = String()

    /// can not be a partial state. Should replace client details state
    public var details: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    public var subIds: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public struct RelationWithValuePerObject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var objectID: String = String()

    public var relations: [Anytype_Model_RelationWithValue] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct HistorySize {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var undo: Int32 = 0

    public var redo: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _restrictions: Anytype_Model_Restrictions? = nil
  fileprivate var _history: Anytype_Model_ObjectView.HistorySize? = nil
}

public struct Anytype_Model_ParticipantPermissionChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identity: String = String()

  public var perms: Anytype_Model_ParticipantPermissions = .reader

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Anytype_Model_Metadata.OneOf_Payload? = nil

  public var identity: Anytype_Model_Metadata.Payload.IdentityPayload {
    get {
      if case .identity(let v)? = payload {return v}
      return Anytype_Model_Metadata.Payload.IdentityPayload()
    }
    set {payload = .identity(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case identity(Anytype_Model_Metadata.Payload.IdentityPayload)

  #if !swift(>=4.1)
    public static func ==(lhs: Anytype_Model_Metadata.OneOf_Payload, rhs: Anytype_Model_Metadata.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.identity, .identity): return {
        guard case .identity(let l) = lhs, case .identity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct IdentityPayload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var profileSymKey: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct Anytype_Model_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var createTime: Int64 = 0

  public var status: Anytype_Model_Notification.Status = .created

  public var isLocal: Bool = false

  public var payload: Anytype_Model_Notification.OneOf_Payload? = nil

  public var `import`: Anytype_Model_Notification.Import {
    get {
      if case .import(let v)? = payload {return v}
      return Anytype_Model_Notification.Import()
    }
    set {payload = .import(newValue)}
  }

  public var export: Anytype_Model_Notification.Export {
    get {
      if case .export(let v)? = payload {return v}
      return Anytype_Model_Notification.Export()
    }
    set {payload = .export(newValue)}
  }

  public var galleryImport: Anytype_Model_Notification.GalleryImport {
    get {
      if case .galleryImport(let v)? = payload {return v}
      return Anytype_Model_Notification.GalleryImport()
    }
    set {payload = .galleryImport(newValue)}
  }

  public var requestToJoin: Anytype_Model_Notification.RequestToJoin {
    get {
      if case .requestToJoin(let v)? = payload {return v}
      return Anytype_Model_Notification.RequestToJoin()
    }
    set {payload = .requestToJoin(newValue)}
  }

  public var test: Anytype_Model_Notification.Test {
    get {
      if case .test(let v)? = payload {return v}
      return Anytype_Model_Notification.Test()
    }
    set {payload = .test(newValue)}
  }

  public var participantRequestApproved: Anytype_Model_Notification.ParticipantRequestApproved {
    get {
      if case .participantRequestApproved(let v)? = payload {return v}
      return Anytype_Model_Notification.ParticipantRequestApproved()
    }
    set {payload = .participantRequestApproved(newValue)}
  }

  public var requestToLeave: Anytype_Model_Notification.RequestToLeave {
    get {
      if case .requestToLeave(let v)? = payload {return v}
      return Anytype_Model_Notification.RequestToLeave()
    }
    set {payload = .requestToLeave(newValue)}
  }

  public var participantRemove: Anytype_Model_Notification.ParticipantRemove {
    get {
      if case .participantRemove(let v)? = payload {return v}
      return Anytype_Model_Notification.ParticipantRemove()
    }
    set {payload = .participantRemove(newValue)}
  }

  public var participantRequestDecline: Anytype_Model_Notification.ParticipantRequestDecline {
    get {
      if case .participantRequestDecline(let v)? = payload {return v}
      return Anytype_Model_Notification.ParticipantRequestDecline()
    }
    set {payload = .participantRequestDecline(newValue)}
  }

  public var participantPermissionsChange: Anytype_Model_Notification.ParticipantPermissionsChange {
    get {
      if case .participantPermissionsChange(let v)? = payload {return v}
      return Anytype_Model_Notification.ParticipantPermissionsChange()
    }
    set {payload = .participantPermissionsChange(newValue)}
  }

  public var space: String = String()

  public var aclHeadID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case `import`(Anytype_Model_Notification.Import)
    case export(Anytype_Model_Notification.Export)
    case galleryImport(Anytype_Model_Notification.GalleryImport)
    case requestToJoin(Anytype_Model_Notification.RequestToJoin)
    case test(Anytype_Model_Notification.Test)
    case participantRequestApproved(Anytype_Model_Notification.ParticipantRequestApproved)
    case requestToLeave(Anytype_Model_Notification.RequestToLeave)
    case participantRemove(Anytype_Model_Notification.ParticipantRemove)
    case participantRequestDecline(Anytype_Model_Notification.ParticipantRequestDecline)
    case participantPermissionsChange(Anytype_Model_Notification.ParticipantPermissionsChange)

  #if !swift(>=4.1)
    public static func ==(lhs: Anytype_Model_Notification.OneOf_Payload, rhs: Anytype_Model_Notification.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.import, .import): return {
        guard case .import(let l) = lhs, case .import(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.export, .export): return {
        guard case .export(let l) = lhs, case .export(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.galleryImport, .galleryImport): return {
        guard case .galleryImport(let l) = lhs, case .galleryImport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestToJoin, .requestToJoin): return {
        guard case .requestToJoin(let l) = lhs, case .requestToJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.test, .test): return {
        guard case .test(let l) = lhs, case .test(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantRequestApproved, .participantRequestApproved): return {
        guard case .participantRequestApproved(let l) = lhs, case .participantRequestApproved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestToLeave, .requestToLeave): return {
        guard case .requestToLeave(let l) = lhs, case .requestToLeave(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantRemove, .participantRemove): return {
        guard case .participantRemove(let l) = lhs, case .participantRemove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantRequestDecline, .participantRequestDecline): return {
        guard case .participantRequestDecline(let l) = lhs, case .participantRequestDecline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantPermissionsChange, .participantPermissionsChange): return {
        guard case .participantPermissionsChange(let l) = lhs, case .participantPermissionsChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case created // = 0
    case shown // = 1
    case read // = 2
    case replied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .created
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .created
      case 1: self = .shown
      case 2: self = .read
      case 3: self = .replied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .created: return 0
      case .shown: return 1
      case .read: return 2
      case .replied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case close // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .close
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .close
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .close: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Import {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var processID: String = String()

    public var errorCode: Anytype_Model_Import.ErrorCode = .null

    public var importType: Anytype_Model_Import.TypeEnum = .notion

    public var spaceID: String = String()

    public var name: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Export {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errorCode: Anytype_Model_Notification.Export.Code = .null

    public var exportType: Anytype_Model_Export.Format = .markdown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case null // = 0
      case unknownError // = 1
      case badInput // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .null
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .null
        case 1: self = .unknownError
        case 2: self = .badInput
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .null: return 0
        case .unknownError: return 1
        case .badInput: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct GalleryImport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var processID: String = String()

    public var errorCode: Anytype_Model_Import.ErrorCode = .null

    public var spaceID: String = String()

    public var name: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RequestToJoin {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var identity: String = String()

    public var identityName: String = String()

    public var identityIcon: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Test {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ParticipantRequestApproved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var permissions: Anytype_Model_ParticipantPermissions = .reader

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RequestToLeave {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var identity: String = String()

    public var identityName: String = String()

    public var identityIcon: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ParticipantRemove {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var identity: String = String()

    public var identityName: String = String()

    public var identityIcon: String = String()

    public var spaceID: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ParticipantRequestDecline {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ParticipantPermissionsChange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var spaceID: String = String()

    public var permissions: Anytype_Model_ParticipantPermissions = .reader

    public var spaceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_Notification.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Notification.Status] = [
    .created,
    .shown,
    .read,
    .replied,
  ]
}

extension Anytype_Model_Notification.ActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Notification.ActionType] = [
    .close,
  ]
}

extension Anytype_Model_Notification.Export.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Notification.Export.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Export {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case markdown // = 0
    case protobuf // = 1
    case json // = 2
    case dot // = 3
    case svg // = 4
    case graphJson // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .markdown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .markdown
      case 1: self = .protobuf
      case 2: self = .json
      case 3: self = .dot
      case 4: self = .svg
      case 5: self = .graphJson
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .markdown: return 0
      case .protobuf: return 1
      case .json: return 2
      case .dot: return 3
      case .svg: return 4
      case .graphJson: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_Export.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Export.Format] = [
    .markdown,
    .protobuf,
    .json,
    .dot,
    .svg,
    .graphJson,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Import {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notion // = 0
    case markdown // = 1

    /// external developers use it
    case external // = 2
    case pb // = 3
    case html // = 4
    case txt // = 5
    case csv // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .notion
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notion
      case 1: self = .markdown
      case 2: self = .external
      case 3: self = .pb
      case 4: self = .html
      case 5: self = .txt
      case 6: self = .csv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notion: return 0
      case .markdown: return 1
      case .external: return 2
      case .pb: return 3
      case .html: return 4
      case .txt: return 5
      case .csv: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ErrorCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case null // = 0
    case unknownError // = 1
    case badInput // = 2
    case internalError // = 3
    case noObjectsToImport // = 5
    case importIsCanceled // = 6
    case limitOfRowsOrRelationsExceeded // = 7
    case fileLoadError // = 8
    case insufficientPermissions // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .null
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .null
      case 1: self = .unknownError
      case 2: self = .badInput
      case 3: self = .internalError
      case 5: self = .noObjectsToImport
      case 6: self = .importIsCanceled
      case 7: self = .limitOfRowsOrRelationsExceeded
      case 8: self = .fileLoadError
      case 9: self = .insufficientPermissions
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .null: return 0
      case .unknownError: return 1
      case .badInput: return 2
      case .internalError: return 3
      case .noObjectsToImport: return 5
      case .importIsCanceled: return 6
      case .limitOfRowsOrRelationsExceeded: return 7
      case .fileLoadError: return 8
      case .insufficientPermissions: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_Import.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Import.TypeEnum] = [
    .notion,
    .markdown,
    .external,
    .pb,
    .html,
    .txt,
    .csv,
  ]
}

extension Anytype_Model_Import.ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Import.ErrorCode] = [
    .null,
    .unknownError,
    .badInput,
    .internalError,
    .noObjectsToImport,
    .importIsCanceled,
    .limitOfRowsOrRelationsExceeded,
    .fileLoadError,
    .insufficientPermissions,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Data = Data()

  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_InvitePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var creatorIdentity: String = String()

  public var creatorName: String = String()

  public var inviteKey: Data = Data()

  public var spaceID: String = String()

  public var spaceName: String = String()

  public var spaceIconCid: String = String()

  public var spaceIconEncryptionKeys: [Anytype_Model_FileEncryptionKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_IdentityProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identity: String = String()

  public var name: String = String()

  public var iconCid: String = String()

  public var iconEncryptionKeys: [Anytype_Model_FileEncryptionKey] = []

  public var description_p: String = String()

  public var globalName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_FileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileID: String = String()

  public var encryptionKeys: [Anytype_Model_FileEncryptionKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_FileEncryptionKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_ManifestInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var schema: String = String()

  public var id: String = String()

  public var name: String = String()

  public var author: String = String()

  public var license: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var screenshots: [String] = []

  public var downloadLink: String = String()

  public var fileSize: Int32 = 0

  public var categories: [String] = []

  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anytype_Model_Membership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// it was Tier before, changed to int32 to allow dynamic values
  public var tier: UInt32 = 0

  public var status: Anytype_Model_Membership.Status = .unknown

  public var dateStarted: UInt64 = 0

  public var dateEnds: UInt64 = 0

  public var isAutoRenew: Bool = false

  public var paymentMethod: Anytype_Model_Membership.PaymentMethod = .methodNone

  /// can be empty if user did not ask for any name
  public var nsName: String = String()

  public var nsNameType: Anytype_Model_NameserviceNameType = .anyName

  /// if the email was verified by the user or set during the checkout - it will be here
  public var userEmail: String = String()

  public var subscribeToNewsletter: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// please wait a bit more, we are still processing your request
    /// the payment is confirmed, but we need more time to do some side-effects:
    /// - increase limits
    /// - send emails
    /// - allocate names
    case pending // = 1

    /// the membership is active, ready to use!
    case active // = 2

    /// in some cases we need to finalize the process:
    /// - if user has bought membership directly without first calling
    /// the BuySubscription method
    /// in this case please call Finalize to finish the process
    case pendingRequiresFinalization // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pending
      case 2: self = .active
      case 3: self = .pendingRequiresFinalization
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pending: return 1
      case .active: return 2
      case .pendingRequiresFinalization: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum PaymentMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case methodNone // = 0
    case methodStripe // = 1
    case methodCrypto // = 2
    case methodInappApple // = 3
    case methodInappGoogle // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .methodNone
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .methodNone
      case 1: self = .methodStripe
      case 2: self = .methodCrypto
      case 3: self = .methodInappApple
      case 4: self = .methodInappGoogle
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .methodNone: return 0
      case .methodStripe: return 1
      case .methodCrypto: return 2
      case .methodInappApple: return 3
      case .methodInappGoogle: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum EmailVerificationStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// user NEVER comleted the verification of the email
    case statusNotVerified // = 0

    /// user has asked for new code, but did not enter it yet
    /// (even if email was verified before, you can ask to UPDATE your e-mail)
    /// please wait, you can not ask for more codes yet
    case statusCodeSent // = 1

    /// the e-mail is finally verified
    case statusVerified // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .statusNotVerified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statusNotVerified
      case 1: self = .statusCodeSent
      case 2: self = .statusVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .statusNotVerified: return 0
      case .statusCodeSent: return 1
      case .statusVerified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Model_Membership.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Membership.Status] = [
    .unknown,
    .pending,
    .active,
    .pendingRequiresFinalization,
  ]
}

extension Anytype_Model_Membership.PaymentMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Membership.PaymentMethod] = [
    .methodNone,
    .methodStripe,
    .methodCrypto,
    .methodInappApple,
    .methodInappGoogle,
  ]
}

extension Anytype_Model_Membership.EmailVerificationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_Membership.EmailVerificationStatus] = [
    .statusNotVerified,
    .statusCodeSent,
    .statusVerified,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Model_MembershipTierData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// this is a unique Payment Node ID of the tier
  /// WARNING: tiers can be sorted differently, not according to their IDs!
  public var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// localazied name of the tier
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// just a short technical description
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// is this tier for testing and debugging only?
  public var isTest: Bool {
    get {return _storage._isTest}
    set {_uniqueStorage()._isTest = newValue}
  }

  /// how long is the period of the subscription
  public var periodType: Anytype_Model_MembershipTierData.PeriodType {
    get {return _storage._periodType}
    set {_uniqueStorage()._periodType = newValue}
  }

  /// i.e. "5 days" or "3 years"
  public var periodValue: UInt32 {
    get {return _storage._periodValue}
    set {_uniqueStorage()._periodValue = newValue}
  }

  /// this one is a price we use ONLY on Stripe platform
  public var priceStripeUsdCents: UInt32 {
    get {return _storage._priceStripeUsdCents}
    set {_uniqueStorage()._priceStripeUsdCents = newValue}
  }

  /// number of ANY NS names that this tier includes 
  /// also in the "features" list (see below)
  public var anyNamesCountIncluded: UInt32 {
    get {return _storage._anyNamesCountIncluded}
    set {_uniqueStorage()._anyNamesCountIncluded = newValue}
  }

  /// somename.any - is of len 8
  public var anyNameMinLength: UInt32 {
    get {return _storage._anyNameMinLength}
    set {_uniqueStorage()._anyNameMinLength = newValue}
  }

  /// localized strings for the features
  public var features: [String] {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  /// green, blue, red, purple, custom
  public var colorStr: String {
    get {return _storage._colorStr}
    set {_uniqueStorage()._colorStr = newValue}
  }

  /// Stripe platform-specific data:
  public var stripeProductID: String {
    get {return _storage._stripeProductID}
    set {_uniqueStorage()._stripeProductID = newValue}
  }

  public var stripeManageURL: String {
    get {return _storage._stripeManageURL}
    set {_uniqueStorage()._stripeManageURL = newValue}
  }

  /// iOS platform-specific data:
  public var iosProductID: String {
    get {return _storage._iosProductID}
    set {_uniqueStorage()._iosProductID = newValue}
  }

  public var iosManageURL: String {
    get {return _storage._iosManageURL}
    set {_uniqueStorage()._iosManageURL = newValue}
  }

  /// Android platform-specific data:
  public var androidProductID: String {
    get {return _storage._androidProductID}
    set {_uniqueStorage()._androidProductID = newValue}
  }

  public var androidManageURL: String {
    get {return _storage._androidManageURL}
    set {_uniqueStorage()._androidManageURL = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PeriodType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case unlimited // = 1
    case days // = 2
    case weeks // = 3
    case months // = 4
    case years // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .unlimited
      case 2: self = .days
      case 3: self = .weeks
      case 4: self = .months
      case 5: self = .years
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .unlimited: return 1
      case .days: return 2
      case .weeks: return 3
      case .months: return 4
      case .years: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Anytype_Model_MembershipTierData.PeriodType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Anytype_Model_MembershipTierData.PeriodType] = [
    .unknown,
    .unlimited,
    .days,
    .weeks,
    .months,
    .years,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Anytype_Model_SmartBlockType: @unchecked Sendable {}
extension Anytype_Model_RelationFormat: @unchecked Sendable {}
extension Anytype_Model_ObjectOrigin: @unchecked Sendable {}
extension Anytype_Model_SpaceStatus: @unchecked Sendable {}
extension Anytype_Model_ParticipantPermissions: @unchecked Sendable {}
extension Anytype_Model_ParticipantStatus: @unchecked Sendable {}
extension Anytype_Model_SpaceAccessType: @unchecked Sendable {}
extension Anytype_Model_ImageKind: @unchecked Sendable {}
extension Anytype_Model_FileIndexingStatus: @unchecked Sendable {}
extension Anytype_Model_SpaceShareableStatus: @unchecked Sendable {}
extension Anytype_Model_NameserviceNameType: @unchecked Sendable {}
extension Anytype_Model_SmartBlockSnapshotBase: @unchecked Sendable {}
extension Anytype_Model_Block: @unchecked Sendable {}
extension Anytype_Model_Block.OneOf_Content: @unchecked Sendable {}
extension Anytype_Model_Block.Position: @unchecked Sendable {}
extension Anytype_Model_Block.Align: @unchecked Sendable {}
extension Anytype_Model_Block.VerticalAlign: @unchecked Sendable {}
extension Anytype_Model_Block.Restrictions: @unchecked Sendable {}
extension Anytype_Model_Block.Content: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Layout: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Layout.Style: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Link: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Link.IconSize: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Link.Style: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Link.Description: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Link.CardStyle: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Div: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Div.Style: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Bookmark: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Bookmark.State: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Icon: @unchecked Sendable {}
extension Anytype_Model_Block.Content.FeaturedRelations: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Text: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Text.Style: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Text.Marks: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Text.Mark: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Text.Mark.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.File: @unchecked Sendable {}
extension Anytype_Model_Block.Content.File.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.File.Style: @unchecked Sendable {}
extension Anytype_Model_Block.Content.File.State: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Smartblock: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View.Size: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.Operator: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.Condition: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.GroupOrder: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.ViewGroup: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.ObjectOrder: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Group: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Group.OneOf_Value: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Status: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Tag: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Checkbox: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Date: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Relation: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Latex: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Latex.Processor: @unchecked Sendable {}
extension Anytype_Model_Block.Content.TableOfContents: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Table: @unchecked Sendable {}
extension Anytype_Model_Block.Content.TableColumn: @unchecked Sendable {}
extension Anytype_Model_Block.Content.TableRow: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Widget: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Widget.Layout: @unchecked Sendable {}
extension Anytype_Model_BlockMetaOnly: @unchecked Sendable {}
extension Anytype_Model_Range: @unchecked Sendable {}
extension Anytype_Model_Account: @unchecked Sendable {}
extension Anytype_Model_Account.StatusType: @unchecked Sendable {}
extension Anytype_Model_Account.Avatar: @unchecked Sendable {}
extension Anytype_Model_Account.Avatar.OneOf_Avatar: @unchecked Sendable {}
extension Anytype_Model_Account.Config: @unchecked Sendable {}
extension Anytype_Model_Account.Status: @unchecked Sendable {}
extension Anytype_Model_Account.Info: @unchecked Sendable {}
extension Anytype_Model_LinkPreview: @unchecked Sendable {}
extension Anytype_Model_LinkPreview.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Restrictions: @unchecked Sendable {}
extension Anytype_Model_Restrictions.ObjectRestriction: @unchecked Sendable {}
extension Anytype_Model_Restrictions.DataviewRestriction: @unchecked Sendable {}
extension Anytype_Model_Restrictions.DataviewRestrictions: @unchecked Sendable {}
extension Anytype_Model_Object: @unchecked Sendable {}
extension Anytype_Model_Object.ChangePayload: @unchecked Sendable {}
extension Anytype_Model_SpaceObjectHeader: @unchecked Sendable {}
extension Anytype_Model_ObjectType: @unchecked Sendable {}
extension Anytype_Model_ObjectType.Layout: @unchecked Sendable {}
extension Anytype_Model_Layout: @unchecked Sendable {}
extension Anytype_Model_RelationWithValue: @unchecked Sendable {}
extension Anytype_Model_Relation: @unchecked Sendable {}
extension Anytype_Model_Relation.Scope: @unchecked Sendable {}
extension Anytype_Model_Relation.DataSource: @unchecked Sendable {}
extension Anytype_Model_Relation.Option: @unchecked Sendable {}
extension Anytype_Model_RelationLink: @unchecked Sendable {}
extension Anytype_Model_Relations: @unchecked Sendable {}
extension Anytype_Model_RelationOptions: @unchecked Sendable {}
extension Anytype_Model_InternalFlag: @unchecked Sendable {}
extension Anytype_Model_InternalFlag.Value: @unchecked Sendable {}
extension Anytype_Model_ObjectView: @unchecked Sendable {}
extension Anytype_Model_ObjectView.DetailsSet: @unchecked Sendable {}
extension Anytype_Model_ObjectView.RelationWithValuePerObject: @unchecked Sendable {}
extension Anytype_Model_ObjectView.HistorySize: @unchecked Sendable {}
extension Anytype_Model_ParticipantPermissionChange: @unchecked Sendable {}
extension Anytype_Model_Metadata: @unchecked Sendable {}
extension Anytype_Model_Metadata.OneOf_Payload: @unchecked Sendable {}
extension Anytype_Model_Metadata.Payload: @unchecked Sendable {}
extension Anytype_Model_Metadata.Payload.IdentityPayload: @unchecked Sendable {}
extension Anytype_Model_Notification: @unchecked Sendable {}
extension Anytype_Model_Notification.OneOf_Payload: @unchecked Sendable {}
extension Anytype_Model_Notification.Status: @unchecked Sendable {}
extension Anytype_Model_Notification.ActionType: @unchecked Sendable {}
extension Anytype_Model_Notification.Import: @unchecked Sendable {}
extension Anytype_Model_Notification.Export: @unchecked Sendable {}
extension Anytype_Model_Notification.Export.Code: @unchecked Sendable {}
extension Anytype_Model_Notification.GalleryImport: @unchecked Sendable {}
extension Anytype_Model_Notification.RequestToJoin: @unchecked Sendable {}
extension Anytype_Model_Notification.Test: @unchecked Sendable {}
extension Anytype_Model_Notification.ParticipantRequestApproved: @unchecked Sendable {}
extension Anytype_Model_Notification.RequestToLeave: @unchecked Sendable {}
extension Anytype_Model_Notification.ParticipantRemove: @unchecked Sendable {}
extension Anytype_Model_Notification.ParticipantRequestDecline: @unchecked Sendable {}
extension Anytype_Model_Notification.ParticipantPermissionsChange: @unchecked Sendable {}
extension Anytype_Model_Export: @unchecked Sendable {}
extension Anytype_Model_Export.Format: @unchecked Sendable {}
extension Anytype_Model_Import: @unchecked Sendable {}
extension Anytype_Model_Import.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Import.ErrorCode: @unchecked Sendable {}
extension Anytype_Model_Invite: @unchecked Sendable {}
extension Anytype_Model_InvitePayload: @unchecked Sendable {}
extension Anytype_Model_IdentityProfile: @unchecked Sendable {}
extension Anytype_Model_FileInfo: @unchecked Sendable {}
extension Anytype_Model_FileEncryptionKey: @unchecked Sendable {}
extension Anytype_Model_ManifestInfo: @unchecked Sendable {}
extension Anytype_Model_Membership: @unchecked Sendable {}
extension Anytype_Model_Membership.Status: @unchecked Sendable {}
extension Anytype_Model_Membership.PaymentMethod: @unchecked Sendable {}
extension Anytype_Model_Membership.EmailVerificationStatus: @unchecked Sendable {}
extension Anytype_Model_MembershipTierData: @unchecked Sendable {}
extension Anytype_Model_MembershipTierData.PeriodType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype.model"

extension Anytype_Model_SmartBlockType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountOld"),
    16: .same(proto: "Page"),
    17: .same(proto: "ProfilePage"),
    32: .same(proto: "Home"),
    48: .same(proto: "Archive"),
    112: .same(proto: "Widget"),
    256: .same(proto: "File"),
    288: .same(proto: "Template"),
    289: .same(proto: "BundledTemplate"),
    512: .same(proto: "BundledRelation"),
    513: .same(proto: "SubObject"),
    514: .same(proto: "BundledObjectType"),
    515: .same(proto: "AnytypeProfile"),
    516: .same(proto: "Date"),
    518: .same(proto: "Workspace"),
    519: .same(proto: "MissingObject"),
    521: .same(proto: "STRelation"),
    528: .same(proto: "STType"),
    529: .same(proto: "STRelationOption"),
    530: .same(proto: "SpaceView"),
    532: .same(proto: "Identity"),
    533: .same(proto: "FileObject"),
    534: .same(proto: "Participant"),
    535: .same(proto: "NotificationObject"),
  ]
}

extension Anytype_Model_RelationFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "longtext"),
    1: .same(proto: "shorttext"),
    2: .same(proto: "number"),
    3: .same(proto: "status"),
    4: .same(proto: "date"),
    5: .same(proto: "file"),
    6: .same(proto: "checkbox"),
    7: .same(proto: "url"),
    8: .same(proto: "email"),
    9: .same(proto: "phone"),
    10: .same(proto: "emoji"),
    11: .same(proto: "tag"),
    100: .same(proto: "object"),
    101: .same(proto: "relations"),
  ]
}

extension Anytype_Model_ObjectOrigin: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "clipboard"),
    2: .same(proto: "dragAndDrop"),
    3: .same(proto: "import"),
    4: .same(proto: "webclipper"),
    5: .same(proto: "sharingExtension"),
    6: .same(proto: "usecase"),
    7: .same(proto: "builtin"),
    8: .same(proto: "bookmark"),
  ]
}

extension Anytype_Model_SpaceStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Loading"),
    2: .same(proto: "Ok"),
    3: .same(proto: "Missing"),
    4: .same(proto: "Error"),
    5: .same(proto: "RemoteWaitingDeletion"),
    6: .same(proto: "RemoteDeleted"),
    7: .same(proto: "SpaceDeleted"),
    8: .same(proto: "SpaceActive"),
    9: .same(proto: "SpaceJoining"),
    10: .same(proto: "SpaceRemoving"),
  ]
}

extension Anytype_Model_ParticipantPermissions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Reader"),
    1: .same(proto: "Writer"),
    2: .same(proto: "Owner"),
    3: .same(proto: "NoPermissions"),
  ]
}

extension Anytype_Model_ParticipantStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Joining"),
    1: .same(proto: "Active"),
    2: .same(proto: "Removed"),
    3: .same(proto: "Declined"),
    4: .same(proto: "Removing"),
    5: .same(proto: "Canceled"),
  ]
}

extension Anytype_Model_SpaceAccessType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Private"),
    1: .same(proto: "Personal"),
    2: .same(proto: "Shared"),
  ]
}

extension Anytype_Model_ImageKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Basic"),
    1: .same(proto: "Cover"),
    2: .same(proto: "Icon"),
  ]
}

extension Anytype_Model_FileIndexingStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotIndexed"),
    1: .same(proto: "Indexed"),
    2: .same(proto: "NotFound"),
  ]
}

extension Anytype_Model_SpaceShareableStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StatusUnknown"),
    1: .same(proto: "StatusShareable"),
    2: .same(proto: "StatusNotShareable"),
  ]
}

extension Anytype_Model_NameserviceNameType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AnyName"),
  ]
}

extension Anytype_Model_SmartBlockSnapshotBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmartBlockSnapshotBase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
    2: .same(proto: "details"),
    3: .same(proto: "fileKeys"),
    4: .same(proto: "extraRelations"),
    5: .same(proto: "objectTypes"),
    6: .same(proto: "collections"),
    8: .same(proto: "removedCollectionKeys"),
    7: .same(proto: "relationLinks"),
    9: .same(proto: "key"),
    10: .same(proto: "originalCreatedTimestamp"),
    11: .same(proto: "fileInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fileKeys) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.extraRelations) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.objectTypes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._collections) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.relationLinks) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.removedCollectionKeys) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.originalCreatedTimestamp) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._fileInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fileKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.extraRelations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extraRelations, fieldNumber: 4)
    }
    if !self.objectTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectTypes, fieldNumber: 5)
    }
    try { if let v = self._collections {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.relationLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationLinks, fieldNumber: 7)
    }
    if !self.removedCollectionKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedCollectionKeys, fieldNumber: 8)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 9)
    }
    if self.originalCreatedTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.originalCreatedTimestamp, fieldNumber: 10)
    }
    try { if let v = self._fileInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_SmartBlockSnapshotBase, rhs: Anytype_Model_SmartBlockSnapshotBase) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs._details != rhs._details {return false}
    if lhs._fileKeys != rhs._fileKeys {return false}
    if lhs.extraRelations != rhs.extraRelations {return false}
    if lhs.objectTypes != rhs.objectTypes {return false}
    if lhs._collections != rhs._collections {return false}
    if lhs.removedCollectionKeys != rhs.removedCollectionKeys {return false}
    if lhs.relationLinks != rhs.relationLinks {return false}
    if lhs.key != rhs.key {return false}
    if lhs.originalCreatedTimestamp != rhs.originalCreatedTimestamp {return false}
    if lhs._fileInfo != rhs._fileInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fields"),
    3: .same(proto: "restrictions"),
    4: .same(proto: "childrenIds"),
    5: .same(proto: "backgroundColor"),
    6: .same(proto: "align"),
    7: .same(proto: "verticalAlign"),
    11: .same(proto: "smartblock"),
    14: .same(proto: "text"),
    15: .same(proto: "file"),
    16: .same(proto: "layout"),
    17: .same(proto: "div"),
    18: .same(proto: "bookmark"),
    19: .same(proto: "icon"),
    20: .same(proto: "link"),
    21: .same(proto: "dataview"),
    22: .same(proto: "relation"),
    23: .same(proto: "featuredRelations"),
    24: .same(proto: "latex"),
    25: .same(proto: "tableOfContents"),
    26: .same(proto: "table"),
    27: .same(proto: "tableColumn"),
    28: .same(proto: "tableRow"),
    29: .same(proto: "widget"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _restrictions: Anytype_Model_Block.Restrictions? = nil
    var _childrenIds: [String] = []
    var _backgroundColor: String = String()
    var _align: Anytype_Model_Block.Align = .left
    var _verticalAlign: Anytype_Model_Block.VerticalAlign = .top
    var _content: Anytype_Model_Block.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fields = source._fields
      _restrictions = source._restrictions
      _childrenIds = source._childrenIds
      _backgroundColor = source._backgroundColor
      _align = source._align
      _verticalAlign = source._verticalAlign
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fields) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._restrictions) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._childrenIds) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._backgroundColor) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._align) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._verticalAlign) }()
        case 11: try {
          var v: Anytype_Model_Block.Content.Smartblock?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .smartblock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .smartblock(v)
          }
        }()
        case 14: try {
          var v: Anytype_Model_Block.Content.Text?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .text(v)
          }
        }()
        case 15: try {
          var v: Anytype_Model_Block.Content.File?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .file(v)
          }
        }()
        case 16: try {
          var v: Anytype_Model_Block.Content.Layout?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .layout(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .layout(v)
          }
        }()
        case 17: try {
          var v: Anytype_Model_Block.Content.Div?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .div(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .div(v)
          }
        }()
        case 18: try {
          var v: Anytype_Model_Block.Content.Bookmark?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .bookmark(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .bookmark(v)
          }
        }()
        case 19: try {
          var v: Anytype_Model_Block.Content.Icon?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .icon(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .icon(v)
          }
        }()
        case 20: try {
          var v: Anytype_Model_Block.Content.Link?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .link(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .link(v)
          }
        }()
        case 21: try {
          var v: Anytype_Model_Block.Content.Dataview?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .dataview(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .dataview(v)
          }
        }()
        case 22: try {
          var v: Anytype_Model_Block.Content.Relation?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .relation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .relation(v)
          }
        }()
        case 23: try {
          var v: Anytype_Model_Block.Content.FeaturedRelations?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .featuredRelations(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .featuredRelations(v)
          }
        }()
        case 24: try {
          var v: Anytype_Model_Block.Content.Latex?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .latex(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .latex(v)
          }
        }()
        case 25: try {
          var v: Anytype_Model_Block.Content.TableOfContents?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .tableOfContents(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .tableOfContents(v)
          }
        }()
        case 26: try {
          var v: Anytype_Model_Block.Content.Table?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .table(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .table(v)
          }
        }()
        case 27: try {
          var v: Anytype_Model_Block.Content.TableColumn?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .tableColumn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .tableColumn(v)
          }
        }()
        case 28: try {
          var v: Anytype_Model_Block.Content.TableRow?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .tableRow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .tableRow(v)
          }
        }()
        case 29: try {
          var v: Anytype_Model_Block.Content.Widget?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .widget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .widget(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._restrictions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._childrenIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._childrenIds, fieldNumber: 4)
      }
      if !_storage._backgroundColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backgroundColor, fieldNumber: 5)
      }
      if _storage._align != .left {
        try visitor.visitSingularEnumField(value: _storage._align, fieldNumber: 6)
      }
      if _storage._verticalAlign != .top {
        try visitor.visitSingularEnumField(value: _storage._verticalAlign, fieldNumber: 7)
      }
      switch _storage._content {
      case .smartblock?: try {
        guard case .smartblock(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .text?: try {
        guard case .text(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .file?: try {
        guard case .file(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .layout?: try {
        guard case .layout(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .div?: try {
        guard case .div(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .bookmark?: try {
        guard case .bookmark(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .icon?: try {
        guard case .icon(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .link?: try {
        guard case .link(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .dataview?: try {
        guard case .dataview(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .relation?: try {
        guard case .relation(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .featuredRelations?: try {
        guard case .featuredRelations(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .latex?: try {
        guard case .latex(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .tableOfContents?: try {
        guard case .tableOfContents(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .table?: try {
        guard case .table(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .tableColumn?: try {
        guard case .tableColumn(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .tableRow?: try {
        guard case .tableRow(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .widget?: try {
        guard case .widget(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block, rhs: Anytype_Model_Block) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._restrictions != rhs_storage._restrictions {return false}
        if _storage._childrenIds != rhs_storage._childrenIds {return false}
        if _storage._backgroundColor != rhs_storage._backgroundColor {return false}
        if _storage._align != rhs_storage._align {return false}
        if _storage._verticalAlign != rhs_storage._verticalAlign {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Position: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Top"),
    2: .same(proto: "Bottom"),
    3: .same(proto: "Left"),
    4: .same(proto: "Right"),
    5: .same(proto: "Inner"),
    6: .same(proto: "Replace"),
    7: .same(proto: "InnerFirst"),
  ]
}

extension Anytype_Model_Block.Align: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AlignLeft"),
    1: .same(proto: "AlignCenter"),
    2: .same(proto: "AlignRight"),
  ]
}

extension Anytype_Model_Block.VerticalAlign: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VerticalAlignTop"),
    1: .same(proto: "VerticalAlignMiddle"),
    2: .same(proto: "VerticalAlignBottom"),
  ]
}

extension Anytype_Model_Block.Restrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.protoMessageName + ".Restrictions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read"),
    2: .same(proto: "edit"),
    3: .same(proto: "remove"),
    4: .same(proto: "drag"),
    5: .same(proto: "dropOn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.edit) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.remove) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.drag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dropOn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 1)
    }
    if self.edit != false {
      try visitor.visitSingularBoolField(value: self.edit, fieldNumber: 2)
    }
    if self.remove != false {
      try visitor.visitSingularBoolField(value: self.remove, fieldNumber: 3)
    }
    if self.drag != false {
      try visitor.visitSingularBoolField(value: self.drag, fieldNumber: 4)
    }
    if self.dropOn != false {
      try visitor.visitSingularBoolField(value: self.dropOn, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Restrictions, rhs: Anytype_Model_Block.Restrictions) -> Bool {
    if lhs.read != rhs.read {return false}
    if lhs.edit != rhs.edit {return false}
    if lhs.remove != rhs.remove {return false}
    if lhs.drag != rhs.drag {return false}
    if lhs.dropOn != rhs.dropOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.protoMessageName + ".Content"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content, rhs: Anytype_Model_Block.Content) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Layout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .row {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Layout, rhs: Anytype_Model_Block.Content.Layout) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Layout.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Row"),
    1: .same(proto: "Column"),
    2: .same(proto: "Div"),
    3: .same(proto: "Header"),
    4: .same(proto: "TableRows"),
    5: .same(proto: "TableColumns"),
  ]
}

extension Anytype_Model_Block.Content.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetBlockId"),
    2: .same(proto: "style"),
    3: .same(proto: "fields"),
    4: .same(proto: "iconSize"),
    5: .same(proto: "cardStyle"),
    6: .same(proto: "description"),
    7: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetBlockID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.iconSize) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.cardStyle) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.description_p) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBlockID, fieldNumber: 1)
    }
    if self.style != .page {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 2)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.iconSize != .sizeNone {
      try visitor.visitSingularEnumField(value: self.iconSize, fieldNumber: 4)
    }
    if self.cardStyle != .text {
      try visitor.visitSingularEnumField(value: self.cardStyle, fieldNumber: 5)
    }
    if self.description_p != .none {
      try visitor.visitSingularEnumField(value: self.description_p, fieldNumber: 6)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relations, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Link, rhs: Anytype_Model_Block.Content.Link) -> Bool {
    if lhs.targetBlockID != rhs.targetBlockID {return false}
    if lhs.style != rhs.style {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.iconSize != rhs.iconSize {return false}
    if lhs.cardStyle != rhs.cardStyle {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Link.IconSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SizeNone"),
    1: .same(proto: "SizeSmall"),
    2: .same(proto: "SizeMedium"),
  ]
}

extension Anytype_Model_Block.Content.Link.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Page"),
    1: .same(proto: "Dataview"),
    2: .same(proto: "Dashboard"),
    3: .same(proto: "Archive"),
  ]
}

extension Anytype_Model_Block.Content.Link.Description: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Added"),
    2: .same(proto: "Content"),
  ]
}

extension Anytype_Model_Block.Content.Link.CardStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Text"),
    1: .same(proto: "Card"),
    2: .same(proto: "Inline"),
  ]
}

extension Anytype_Model_Block.Content.Div: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Div"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .line {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Div, rhs: Anytype_Model_Block.Content.Div) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Div.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Line"),
    1: .same(proto: "Dots"),
  ]
}

extension Anytype_Model_Block.Content.Bookmark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Bookmark"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "imageHash"),
    5: .same(proto: "faviconHash"),
    6: .same(proto: "type"),
    7: .same(proto: "targetObjectId"),
    8: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imageHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.faviconHash) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.targetObjectID) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.imageHash.isEmpty {
      try visitor.visitSingularStringField(value: self.imageHash, fieldNumber: 4)
    }
    if !self.faviconHash.isEmpty {
      try visitor.visitSingularStringField(value: self.faviconHash, fieldNumber: 5)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 6)
    }
    if !self.targetObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetObjectID, fieldNumber: 7)
    }
    if self.state != .empty {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Bookmark, rhs: Anytype_Model_Block.Content.Bookmark) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.imageHash != rhs.imageHash {return false}
    if lhs.faviconHash != rhs.faviconHash {return false}
    if lhs.type != rhs.type {return false}
    if lhs.targetObjectID != rhs.targetObjectID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Bookmark.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Empty"),
    1: .same(proto: "Fetching"),
    2: .same(proto: "Done"),
    3: .same(proto: "Error"),
  ]
}

extension Anytype_Model_Block.Content.Icon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Icon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Icon, rhs: Anytype_Model_Block.Content.Icon) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.FeaturedRelations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".FeaturedRelations"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.FeaturedRelations, rhs: Anytype_Model_Block.Content.FeaturedRelations) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "style"),
    3: .same(proto: "marks"),
    4: .same(proto: "checked"),
    5: .same(proto: "color"),
    6: .same(proto: "iconEmoji"),
    7: .same(proto: "iconImage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._marks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.checked) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.color) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.iconEmoji) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.iconImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.style != .paragraph {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 2)
    }
    try { if let v = self._marks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.checked != false {
      try visitor.visitSingularBoolField(value: self.checked, fieldNumber: 4)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 5)
    }
    if !self.iconEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.iconEmoji, fieldNumber: 6)
    }
    if !self.iconImage.isEmpty {
      try visitor.visitSingularStringField(value: self.iconImage, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Text, rhs: Anytype_Model_Block.Content.Text) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.style != rhs.style {return false}
    if lhs._marks != rhs._marks {return false}
    if lhs.checked != rhs.checked {return false}
    if lhs.color != rhs.color {return false}
    if lhs.iconEmoji != rhs.iconEmoji {return false}
    if lhs.iconImage != rhs.iconImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Paragraph"),
    1: .same(proto: "Header1"),
    2: .same(proto: "Header2"),
    3: .same(proto: "Header3"),
    4: .same(proto: "Header4"),
    5: .same(proto: "Quote"),
    6: .same(proto: "Code"),
    7: .same(proto: "Title"),
    8: .same(proto: "Checkbox"),
    9: .same(proto: "Marked"),
    10: .same(proto: "Numbered"),
    11: .same(proto: "Toggle"),
    12: .same(proto: "Description"),
    13: .same(proto: "Callout"),
  ]
}

extension Anytype_Model_Block.Content.Text.Marks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Text.protoMessageName + ".Marks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "marks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.marks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Text.Marks, rhs: Anytype_Model_Block.Content.Text.Marks) -> Bool {
    if lhs.marks != rhs.marks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Mark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Text.protoMessageName + ".Mark"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "range"),
    2: .same(proto: "type"),
    3: .same(proto: "param"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.param) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .strikethrough {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.param.isEmpty {
      try visitor.visitSingularStringField(value: self.param, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Text.Mark, rhs: Anytype_Model_Block.Content.Text.Mark) -> Bool {
    if lhs._range != rhs._range {return false}
    if lhs.type != rhs.type {return false}
    if lhs.param != rhs.param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Text.Mark.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Strikethrough"),
    1: .same(proto: "Keyboard"),
    2: .same(proto: "Italic"),
    3: .same(proto: "Bold"),
    4: .same(proto: "Underscored"),
    5: .same(proto: "Link"),
    6: .same(proto: "TextColor"),
    7: .same(proto: "BackgroundColor"),
    8: .same(proto: "Mention"),
    9: .same(proto: "Emoji"),
    10: .same(proto: "Object"),
  ]
}

extension Anytype_Model_Block.Content.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "mime"),
    5: .same(proto: "size"),
    6: .same(proto: "addedAt"),
    9: .same(proto: "targetObjectId"),
    7: .same(proto: "state"),
    8: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.addedAt) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.targetObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 5)
    }
    if self.addedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.addedAt, fieldNumber: 6)
    }
    if self.state != .empty {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    if self.style != .auto {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 8)
    }
    if !self.targetObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetObjectID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.File, rhs: Anytype_Model_Block.Content.File) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mime != rhs.mime {return false}
    if lhs.size != rhs.size {return false}
    if lhs.addedAt != rhs.addedAt {return false}
    if lhs.targetObjectID != rhs.targetObjectID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.File.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "File"),
    2: .same(proto: "Image"),
    3: .same(proto: "Video"),
    4: .same(proto: "Audio"),
    5: .same(proto: "PDF"),
  ]
}

extension Anytype_Model_Block.Content.File.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Auto"),
    1: .same(proto: "Link"),
    2: .same(proto: "Embed"),
  ]
}

extension Anytype_Model_Block.Content.File.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Empty"),
    1: .same(proto: "Uploading"),
    2: .same(proto: "Done"),
    3: .same(proto: "Error"),
  ]
}

extension Anytype_Model_Block.Content.Smartblock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Smartblock"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Smartblock, rhs: Anytype_Model_Block.Content.Smartblock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Dataview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "views"),
    4: .same(proto: "relations"),
    3: .same(proto: "activeView"),
    12: .same(proto: "groupOrders"),
    13: .same(proto: "objectOrders"),
    5: .same(proto: "relationLinks"),
    6: .same(proto: "TargetObjectId"),
    14: .same(proto: "isCollection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.views) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activeView) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.relationLinks) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.targetObjectID) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.groupOrders) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.objectOrders) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.isCollection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 1)
    }
    if !self.views.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.views, fieldNumber: 2)
    }
    if !self.activeView.isEmpty {
      try visitor.visitSingularStringField(value: self.activeView, fieldNumber: 3)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 4)
    }
    if !self.relationLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationLinks, fieldNumber: 5)
    }
    if !self.targetObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetObjectID, fieldNumber: 6)
    }
    if !self.groupOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupOrders, fieldNumber: 12)
    }
    if !self.objectOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectOrders, fieldNumber: 13)
    }
    if self.isCollection != false {
      try visitor.visitSingularBoolField(value: self.isCollection, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview, rhs: Anytype_Model_Block.Content.Dataview) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.views != rhs.views {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.activeView != rhs.activeView {return false}
    if lhs.groupOrders != rhs.groupOrders {return false}
    if lhs.objectOrders != rhs.objectOrders {return false}
    if lhs.relationLinks != rhs.relationLinks {return false}
    if lhs.targetObjectID != rhs.targetObjectID {return false}
    if lhs.isCollection != rhs.isCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "sorts"),
    5: .same(proto: "filters"),
    6: .same(proto: "relations"),
    7: .same(proto: "coverRelationKey"),
    8: .same(proto: "hideIcon"),
    9: .same(proto: "cardSize"),
    10: .same(proto: "coverFit"),
    11: .same(proto: "groupRelationKey"),
    12: .same(proto: "groupBackgroundColors"),
    13: .same(proto: "pageLimit"),
    14: .same(proto: "defaultTemplateId"),
    15: .same(proto: "defaultObjectTypeId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.coverRelationKey) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hideIcon) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.cardSize) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.coverFit) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.groupRelationKey) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.groupBackgroundColors) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.pageLimit) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.defaultTemplateID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.defaultObjectTypeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .table {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.sorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sorts, fieldNumber: 4)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 5)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 6)
    }
    if !self.coverRelationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.coverRelationKey, fieldNumber: 7)
    }
    if self.hideIcon != false {
      try visitor.visitSingularBoolField(value: self.hideIcon, fieldNumber: 8)
    }
    if self.cardSize != .small {
      try visitor.visitSingularEnumField(value: self.cardSize, fieldNumber: 9)
    }
    if self.coverFit != false {
      try visitor.visitSingularBoolField(value: self.coverFit, fieldNumber: 10)
    }
    if !self.groupRelationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.groupRelationKey, fieldNumber: 11)
    }
    if self.groupBackgroundColors != false {
      try visitor.visitSingularBoolField(value: self.groupBackgroundColors, fieldNumber: 12)
    }
    if self.pageLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.pageLimit, fieldNumber: 13)
    }
    if !self.defaultTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultTemplateID, fieldNumber: 14)
    }
    if !self.defaultObjectTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultObjectTypeID, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.View, rhs: Anytype_Model_Block.Content.Dataview.View) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sorts != rhs.sorts {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.coverRelationKey != rhs.coverRelationKey {return false}
    if lhs.hideIcon != rhs.hideIcon {return false}
    if lhs.cardSize != rhs.cardSize {return false}
    if lhs.coverFit != rhs.coverFit {return false}
    if lhs.groupRelationKey != rhs.groupRelationKey {return false}
    if lhs.groupBackgroundColors != rhs.groupBackgroundColors {return false}
    if lhs.pageLimit != rhs.pageLimit {return false}
    if lhs.defaultTemplateID != rhs.defaultTemplateID {return false}
    if lhs.defaultObjectTypeID != rhs.defaultObjectTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Table"),
    1: .same(proto: "List"),
    2: .same(proto: "Gallery"),
    3: .same(proto: "Kanban"),
    4: .same(proto: "Calendar"),
    5: .same(proto: "Graph"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.View.Size: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Small"),
    1: .same(proto: "Medium"),
    2: .same(proto: "Large"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Relation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "isVisible"),
    3: .same(proto: "width"),
    5: .same(proto: "dateIncludeTime"),
    6: .same(proto: "timeFormat"),
    7: .same(proto: "dateFormat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isVisible) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dateIncludeTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.timeFormat) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.dateFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.isVisible != false {
      try visitor.visitSingularBoolField(value: self.isVisible, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.dateIncludeTime != false {
      try visitor.visitSingularBoolField(value: self.dateIncludeTime, fieldNumber: 5)
    }
    if self.timeFormat != .format12 {
      try visitor.visitSingularEnumField(value: self.timeFormat, fieldNumber: 6)
    }
    if self.dateFormat != .monthAbbrBeforeDay {
      try visitor.visitSingularEnumField(value: self.dateFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Relation, rhs: Anytype_Model_Block.Content.Dataview.Relation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.isVisible != rhs.isVisible {return false}
    if lhs.width != rhs.width {return false}
    if lhs.dateIncludeTime != rhs.dateIncludeTime {return false}
    if lhs.timeFormat != rhs.timeFormat {return false}
    if lhs.dateFormat != rhs.dateFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MonthAbbrBeforeDay"),
    1: .same(proto: "MonthAbbrAfterDay"),
    2: .same(proto: "Short"),
    3: .same(proto: "ShortUS"),
    4: .same(proto: "ISO"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Format12"),
    1: .same(proto: "Format24"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Sort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RelationKey"),
    2: .same(proto: "type"),
    3: .same(proto: "customOrder"),
    4: .same(proto: "format"),
    5: .same(proto: "includeTime"),
    6: .same(proto: "id"),
    7: .same(proto: "emptyPlacement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.customOrder) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.emptyPlacement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 1)
    }
    if self.type != .asc {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.customOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customOrder, fieldNumber: 3)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    if self.includeTime != false {
      try visitor.visitSingularBoolField(value: self.includeTime, fieldNumber: 5)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 6)
    }
    if self.emptyPlacement != .notSpecified {
      try visitor.visitSingularEnumField(value: self.emptyPlacement, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Sort, rhs: Anytype_Model_Block.Content.Dataview.Sort) -> Bool {
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.type != rhs.type {return false}
    if lhs.customOrder != rhs.customOrder {return false}
    if lhs.format != rhs.format {return false}
    if lhs.includeTime != rhs.includeTime {return false}
    if lhs.id != rhs.id {return false}
    if lhs.emptyPlacement != rhs.emptyPlacement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Asc"),
    1: .same(proto: "Desc"),
    2: .same(proto: "Custom"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotSpecified"),
    1: .same(proto: "Start"),
    2: .same(proto: "End"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "operator"),
    2: .same(proto: "RelationKey"),
    5: .same(proto: "relationProperty"),
    3: .same(proto: "condition"),
    4: .same(proto: "value"),
    6: .same(proto: "quickOption"),
    7: .same(proto: "format"),
    8: .same(proto: "includeTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.condition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.relationProperty) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quickOption) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.includeTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.`operator` != .and {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    if self.condition != .none {
      try visitor.visitSingularEnumField(value: self.condition, fieldNumber: 3)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.relationProperty.isEmpty {
      try visitor.visitSingularStringField(value: self.relationProperty, fieldNumber: 5)
    }
    if self.quickOption != .exactDate {
      try visitor.visitSingularEnumField(value: self.quickOption, fieldNumber: 6)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 7)
    }
    if self.includeTime != false {
      try visitor.visitSingularBoolField(value: self.includeTime, fieldNumber: 8)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Filter, rhs: Anytype_Model_Block.Content.Dataview.Filter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.relationProperty != rhs.relationProperty {return false}
    if lhs.condition != rhs.condition {return false}
    if lhs._value != rhs._value {return false}
    if lhs.quickOption != rhs.quickOption {return false}
    if lhs.format != rhs.format {return false}
    if lhs.includeTime != rhs.includeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Filter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "And"),
    1: .same(proto: "Or"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Condition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Equal"),
    2: .same(proto: "NotEqual"),
    3: .same(proto: "Greater"),
    4: .same(proto: "Less"),
    5: .same(proto: "GreaterOrEqual"),
    6: .same(proto: "LessOrEqual"),
    7: .same(proto: "Like"),
    8: .same(proto: "NotLike"),
    9: .same(proto: "In"),
    10: .same(proto: "NotIn"),
    11: .same(proto: "Empty"),
    12: .same(proto: "NotEmpty"),
    13: .same(proto: "AllIn"),
    14: .same(proto: "NotAllIn"),
    15: .same(proto: "ExactIn"),
    16: .same(proto: "NotExactIn"),
    17: .same(proto: "Exists"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ExactDate"),
    1: .same(proto: "Yesterday"),
    2: .same(proto: "Today"),
    3: .same(proto: "Tomorrow"),
    4: .same(proto: "LastWeek"),
    5: .same(proto: "CurrentWeek"),
    6: .same(proto: "NextWeek"),
    7: .same(proto: "LastMonth"),
    8: .same(proto: "CurrentMonth"),
    9: .same(proto: "NextMonth"),
    10: .same(proto: "NumberOfDaysAgo"),
    11: .same(proto: "NumberOfDaysNow"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.GroupOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".GroupOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewId"),
    2: .same(proto: "viewGroups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.viewGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 1)
    }
    if !self.viewGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.viewGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.GroupOrder, rhs: Anytype_Model_Block.Content.Dataview.GroupOrder) -> Bool {
    if lhs.viewID != rhs.viewID {return false}
    if lhs.viewGroups != rhs.viewGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.ViewGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".ViewGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupId"),
    2: .same(proto: "index"),
    3: .same(proto: "hidden"),
    4: .same(proto: "backgroundColor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.backgroundColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 3)
    }
    if !self.backgroundColor.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundColor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.ViewGroup, rhs: Anytype_Model_Block.Content.Dataview.ViewGroup) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.backgroundColor != rhs.backgroundColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.ObjectOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".ObjectOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewId"),
    2: .same(proto: "groupId"),
    3: .same(proto: "objectIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 2)
    }
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.ObjectOrder, rhs: Anytype_Model_Block.Content.Dataview.ObjectOrder) -> Bool {
    if lhs.viewID != rhs.viewID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .same(proto: "tag"),
    4: .same(proto: "checkbox"),
    5: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Anytype_Model_Block.Content.Dataview.Status?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .status(v)
        }
      }()
      case 3: try {
        var v: Anytype_Model_Block.Content.Dataview.Tag?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tag(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tag(v)
        }
      }()
      case 4: try {
        var v: Anytype_Model_Block.Content.Dataview.Checkbox?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkbox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkbox(v)
        }
      }()
      case 5: try {
        var v: Anytype_Model_Block.Content.Dataview.Date?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .date(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.value {
    case .status?: try {
      guard case .status(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tag?: try {
      guard case .tag(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .checkbox?: try {
      guard case .checkbox(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Group, rhs: Anytype_Model_Block.Content.Dataview.Group) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Status, rhs: Anytype_Model_Block.Content.Dataview.Status) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Tag, rhs: Anytype_Model_Block.Content.Dataview.Tag) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Checkbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Checkbox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "checked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.checked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.checked != false {
      try visitor.visitSingularBoolField(value: self.checked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Checkbox, rhs: Anytype_Model_Block.Content.Dataview.Checkbox) -> Bool {
    if lhs.checked != rhs.checked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Date"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Date, rhs: Anytype_Model_Block.Content.Dataview.Date) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Relation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Relation, rhs: Anytype_Model_Block.Content.Relation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Latex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Latex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "processor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.processor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.processor != .latex {
      try visitor.visitSingularEnumField(value: self.processor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Latex, rhs: Anytype_Model_Block.Content.Latex) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.processor != rhs.processor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Latex.Processor: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Latex"),
    1: .same(proto: "Mermaid"),
    2: .same(proto: "Chart"),
    3: .same(proto: "Youtube"),
    4: .same(proto: "Vimeo"),
    5: .same(proto: "Soundcloud"),
    6: .same(proto: "GoogleMaps"),
    7: .same(proto: "Miro"),
    8: .same(proto: "Figma"),
    9: .same(proto: "Twitter"),
    10: .same(proto: "OpenStreetMap"),
    11: .same(proto: "Reddit"),
    12: .same(proto: "Facebook"),
    13: .same(proto: "Instagram"),
    14: .same(proto: "Telegram"),
    15: .same(proto: "GithubGist"),
    16: .same(proto: "Codepen"),
    17: .same(proto: "Bilibili"),
    18: .same(proto: "Excalidraw"),
  ]
}

extension Anytype_Model_Block.Content.TableOfContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".TableOfContents"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.TableOfContents, rhs: Anytype_Model_Block.Content.TableOfContents) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Table"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Table, rhs: Anytype_Model_Block.Content.Table) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.TableColumn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".TableColumn"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.TableColumn, rhs: Anytype_Model_Block.Content.TableColumn) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.TableRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".TableRow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHeader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHeader != false {
      try visitor.visitSingularBoolField(value: self.isHeader, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.TableRow, rhs: Anytype_Model_Block.Content.TableRow) -> Bool {
    if lhs.isHeader != rhs.isHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Widget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Widget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layout"),
    2: .same(proto: "limit"),
    3: .same(proto: "viewId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.layout) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.layout != .link {
      try visitor.visitSingularEnumField(value: self.layout, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Widget, rhs: Anytype_Model_Block.Content.Widget) -> Bool {
    if lhs.layout != rhs.layout {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Widget.Layout: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Link"),
    1: .same(proto: "Tree"),
    2: .same(proto: "List"),
    3: .same(proto: "CompactList"),
  ]
}

extension Anytype_Model_BlockMetaOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockMetaOnly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_BlockMetaOnly, rhs: Anytype_Model_BlockMetaOnly) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.from) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.from != 0 {
      try visitor.visitSingularInt32Field(value: self.from, fieldNumber: 1)
    }
    if self.to != 0 {
      try visitor.visitSingularInt32Field(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Range, rhs: Anytype_Model_Range) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "config"),
    5: .same(proto: "status"),
    6: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _avatar: Anytype_Model_Account.Avatar? = nil
    var _config: Anytype_Model_Account.Config? = nil
    var _status: Anytype_Model_Account.Status? = nil
    var _info: Anytype_Model_Account.Info? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _avatar = source._avatar
      _config = source._config
      _status = source._status
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Account, rhs: Anytype_Model_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account.StatusType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Active"),
    1: .same(proto: "PendingDeletion"),
    2: .same(proto: "StartedDeletion"),
    3: .same(proto: "Deleted"),
  ]
}

extension Anytype_Model_Account.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Account.protoMessageName + ".Avatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anytype_Model_Block.Content.File?
        var hadOneofValue = false
        if let current = self.avatar {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.avatar = .image(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.avatar != nil {try decoder.handleConflictingOneOf()}
          self.avatar = .color(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.avatar {
    case .image?: try {
      guard case .image(let v)? = self.avatar else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .color?: try {
      guard case .color(let v)? = self.avatar else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Account.Avatar, rhs: Anytype_Model_Account.Avatar) -> Bool {
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account.Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Account.protoMessageName + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enableDataview"),
    2: .same(proto: "enableDebug"),
    3: .same(proto: "enablePrereleaseChannel"),
    4: .same(proto: "enableSpaces"),
    100: .same(proto: "extra"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableDataview) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableDebug) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enablePrereleaseChannel) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableSpaces) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enableDataview != false {
      try visitor.visitSingularBoolField(value: self.enableDataview, fieldNumber: 1)
    }
    if self.enableDebug != false {
      try visitor.visitSingularBoolField(value: self.enableDebug, fieldNumber: 2)
    }
    if self.enablePrereleaseChannel != false {
      try visitor.visitSingularBoolField(value: self.enablePrereleaseChannel, fieldNumber: 3)
    }
    if self.enableSpaces != false {
      try visitor.visitSingularBoolField(value: self.enableSpaces, fieldNumber: 4)
    }
    try { if let v = self._extra {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Account.Config, rhs: Anytype_Model_Account.Config) -> Bool {
    if lhs.enableDataview != rhs.enableDataview {return false}
    if lhs.enableDebug != rhs.enableDebug {return false}
    if lhs.enablePrereleaseChannel != rhs.enablePrereleaseChannel {return false}
    if lhs.enableSpaces != rhs.enableSpaces {return false}
    if lhs._extra != rhs._extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Account.protoMessageName + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statusType"),
    2: .same(proto: "deletionDate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.statusType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.deletionDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusType != .active {
      try visitor.visitSingularEnumField(value: self.statusType, fieldNumber: 1)
    }
    if self.deletionDate != 0 {
      try visitor.visitSingularInt64Field(value: self.deletionDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Account.Status, rhs: Anytype_Model_Account.Status) -> Bool {
    if lhs.statusType != rhs.statusType {return false}
    if lhs.deletionDate != rhs.deletionDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Account.Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Account.protoMessageName + ".Info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "homeObjectId"),
    3: .same(proto: "archiveObjectId"),
    4: .same(proto: "profileObjectId"),
    11: .same(proto: "marketplaceWorkspaceId"),
    8: .same(proto: "deviceId"),
    9: .same(proto: "accountSpaceId"),
    10: .same(proto: "widgetsId"),
    13: .same(proto: "spaceViewId"),
    14: .same(proto: "techSpaceId"),
    101: .same(proto: "gatewayUrl"),
    103: .same(proto: "localStoragePath"),
    104: .same(proto: "timeZone"),
    105: .same(proto: "analyticsId"),
    106: .same(proto: "networkId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeObjectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.archiveObjectID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.profileObjectID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.accountSpaceID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.widgetsID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.marketplaceWorkspaceID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.spaceViewID) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.techSpaceID) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self.gatewayURL) }()
      case 103: try { try decoder.decodeSingularStringField(value: &self.localStoragePath) }()
      case 104: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      case 105: try { try decoder.decodeSingularStringField(value: &self.analyticsID) }()
      case 106: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.homeObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.homeObjectID, fieldNumber: 2)
    }
    if !self.archiveObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.archiveObjectID, fieldNumber: 3)
    }
    if !self.profileObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.profileObjectID, fieldNumber: 4)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 8)
    }
    if !self.accountSpaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountSpaceID, fieldNumber: 9)
    }
    if !self.widgetsID.isEmpty {
      try visitor.visitSingularStringField(value: self.widgetsID, fieldNumber: 10)
    }
    if !self.marketplaceWorkspaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketplaceWorkspaceID, fieldNumber: 11)
    }
    if !self.spaceViewID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceViewID, fieldNumber: 13)
    }
    if !self.techSpaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.techSpaceID, fieldNumber: 14)
    }
    if !self.gatewayURL.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayURL, fieldNumber: 101)
    }
    if !self.localStoragePath.isEmpty {
      try visitor.visitSingularStringField(value: self.localStoragePath, fieldNumber: 103)
    }
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 104)
    }
    if !self.analyticsID.isEmpty {
      try visitor.visitSingularStringField(value: self.analyticsID, fieldNumber: 105)
    }
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 106)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Account.Info, rhs: Anytype_Model_Account.Info) -> Bool {
    if lhs.homeObjectID != rhs.homeObjectID {return false}
    if lhs.archiveObjectID != rhs.archiveObjectID {return false}
    if lhs.profileObjectID != rhs.profileObjectID {return false}
    if lhs.marketplaceWorkspaceID != rhs.marketplaceWorkspaceID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.accountSpaceID != rhs.accountSpaceID {return false}
    if lhs.widgetsID != rhs.widgetsID {return false}
    if lhs.spaceViewID != rhs.spaceViewID {return false}
    if lhs.techSpaceID != rhs.techSpaceID {return false}
    if lhs.gatewayURL != rhs.gatewayURL {return false}
    if lhs.localStoragePath != rhs.localStoragePath {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.analyticsID != rhs.analyticsID {return false}
    if lhs.networkID != rhs.networkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "imageUrl"),
    5: .same(proto: "faviconUrl"),
    6: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.faviconURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 4)
    }
    if !self.faviconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faviconURL, fieldNumber: 5)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_LinkPreview, rhs: Anytype_Model_LinkPreview) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.faviconURL != rhs.faviconURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_LinkPreview.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Page"),
    2: .same(proto: "Image"),
    3: .same(proto: "Text"),
  ]
}

extension Anytype_Model_Restrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Restrictions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "object"),
    2: .same(proto: "dataview"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.object) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dataview) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.object.isEmpty {
      try visitor.visitPackedEnumField(value: self.object, fieldNumber: 1)
    }
    if !self.dataview.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataview, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Restrictions, rhs: Anytype_Model_Restrictions) -> Bool {
    if lhs.object != rhs.object {return false}
    if lhs.dataview != rhs.dataview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Restrictions.ObjectRestriction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Delete"),
    2: .same(proto: "Relations"),
    3: .same(proto: "Blocks"),
    4: .same(proto: "Details"),
    5: .same(proto: "TypeChange"),
    6: .same(proto: "LayoutChange"),
    7: .same(proto: "Template"),
    8: .same(proto: "Duplicate"),
    9: .same(proto: "CreateObjectOfThisType"),
  ]
}

extension Anytype_Model_Restrictions.DataviewRestriction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DVNone"),
    1: .same(proto: "DVRelation"),
    2: .same(proto: "DVCreateObject"),
    3: .same(proto: "DVViews"),
  ]
}

extension Anytype_Model_Restrictions.DataviewRestrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Restrictions.protoMessageName + ".DataviewRestrictions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockId"),
    2: .same(proto: "restrictions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.restrictions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 1)
    }
    if !self.restrictions.isEmpty {
      try visitor.visitPackedEnumField(value: self.restrictions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Restrictions.DataviewRestrictions, rhs: Anytype_Model_Restrictions.DataviewRestrictions) -> Bool {
    if lhs.blockID != rhs.blockID {return false}
    if lhs.restrictions != rhs.restrictions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Object: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Object"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Object, rhs: Anytype_Model_Object) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Object.ChangePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Object.protoMessageName + ".ChangePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "smartBlockType"),
    2: .same(proto: "key"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.smartBlockType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.smartBlockType != .accountOld {
      try visitor.visitSingularEnumField(value: self.smartBlockType, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Object.ChangePayload, rhs: Anytype_Model_Object.ChangePayload) -> Bool {
    if lhs.smartBlockType != rhs.smartBlockType {return false}
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_SpaceObjectHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpaceObjectHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_SpaceObjectHeader, rhs: Anytype_Model_SpaceObjectHeader) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ObjectType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "name"),
    3: .same(proto: "relationLinks"),
    4: .same(proto: "layout"),
    5: .same(proto: "iconEmoji"),
    6: .same(proto: "description"),
    7: .same(proto: "hidden"),
    10: .same(proto: "readonly"),
    8: .same(proto: "types"),
    9: .same(proto: "isArchived"),
    11: .same(proto: "installedByDefault"),
    12: .same(proto: "key"),
    13: .same(proto: "revision"),
    14: .same(proto: "restrictObjectCreation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.relationLinks) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.layout) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.iconEmoji) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 8: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.readonly) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.installedByDefault) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.revision) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.restrictObjectCreation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.relationLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationLinks, fieldNumber: 3)
    }
    if self.layout != .basic {
      try visitor.visitSingularEnumField(value: self.layout, fieldNumber: 4)
    }
    if !self.iconEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.iconEmoji, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 7)
    }
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 8)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 9)
    }
    if self.readonly != false {
      try visitor.visitSingularBoolField(value: self.readonly, fieldNumber: 10)
    }
    if self.installedByDefault != false {
      try visitor.visitSingularBoolField(value: self.installedByDefault, fieldNumber: 11)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 12)
    }
    if self.revision != 0 {
      try visitor.visitSingularInt64Field(value: self.revision, fieldNumber: 13)
    }
    if self.restrictObjectCreation != false {
      try visitor.visitSingularBoolField(value: self.restrictObjectCreation, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ObjectType, rhs: Anytype_Model_ObjectType) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.name != rhs.name {return false}
    if lhs.relationLinks != rhs.relationLinks {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs.iconEmoji != rhs.iconEmoji {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.readonly != rhs.readonly {return false}
    if lhs.types != rhs.types {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.installedByDefault != rhs.installedByDefault {return false}
    if lhs.key != rhs.key {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.restrictObjectCreation != rhs.restrictObjectCreation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ObjectType.Layout: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "basic"),
    1: .same(proto: "profile"),
    2: .same(proto: "todo"),
    3: .same(proto: "set"),
    4: .same(proto: "objectType"),
    5: .same(proto: "relation"),
    6: .same(proto: "file"),
    7: .same(proto: "dashboard"),
    8: .same(proto: "image"),
    9: .same(proto: "note"),
    10: .same(proto: "space"),
    11: .same(proto: "bookmark"),
    12: .same(proto: "relationOptionsList"),
    13: .same(proto: "relationOption"),
    14: .same(proto: "collection"),
    15: .same(proto: "audio"),
    16: .same(proto: "video"),
    17: .same(proto: "date"),
    18: .same(proto: "spaceView"),
    19: .same(proto: "participant"),
    20: .same(proto: "pdf"),
  ]
}

extension Anytype_Model_Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Layout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "requiredRelations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.requiredRelations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != .basic {
      try visitor.visitSingularEnumField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.requiredRelations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requiredRelations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Layout, rhs: Anytype_Model_Layout) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.requiredRelations != rhs.requiredRelations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_RelationWithValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationWithValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relation"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._relation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._relation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_RelationWithValue, rhs: Anytype_Model_RelationWithValue) -> Bool {
    if lhs._relation != rhs._relation {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Relation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "id"),
    1: .same(proto: "key"),
    2: .same(proto: "format"),
    3: .same(proto: "name"),
    4: .same(proto: "defaultValue"),
    5: .same(proto: "dataSource"),
    6: .same(proto: "hidden"),
    7: .same(proto: "readOnly"),
    15: .same(proto: "readOnlyRelation"),
    8: .same(proto: "multi"),
    9: .same(proto: "objectTypes"),
    12: .same(proto: "selectDict"),
    13: .same(proto: "maxCount"),
    14: .same(proto: "description"),
    20: .same(proto: "scope"),
    21: .same(proto: "creator"),
    22: .same(proto: "revision"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _key: String = String()
    var _format: Anytype_Model_RelationFormat = .longtext
    var _name: String = String()
    var _defaultValue: SwiftProtobuf.Google_Protobuf_Value? = nil
    var _dataSource: Anytype_Model_Relation.DataSource = .details
    var _hidden: Bool = false
    var _readOnly: Bool = false
    var _readOnlyRelation: Bool = false
    var _multi: Bool = false
    var _objectTypes: [String] = []
    var _selectDict: [Anytype_Model_Relation.Option] = []
    var _maxCount: Int32 = 0
    var _description_p: String = String()
    var _scope: Anytype_Model_Relation.Scope = .object
    var _creator: String = String()
    var _revision: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _key = source._key
      _format = source._format
      _name = source._name
      _defaultValue = source._defaultValue
      _dataSource = source._dataSource
      _hidden = source._hidden
      _readOnly = source._readOnly
      _readOnlyRelation = source._readOnlyRelation
      _multi = source._multi
      _objectTypes = source._objectTypes
      _selectDict = source._selectDict
      _maxCount = source._maxCount
      _description_p = source._description_p
      _scope = source._scope
      _creator = source._creator
      _revision = source._revision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._format) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._defaultValue) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._dataSource) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._readOnly) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._multi) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._objectTypes) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._selectDict) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._maxCount) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._readOnlyRelation) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._scope) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._revision) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if _storage._format != .longtext {
        try visitor.visitSingularEnumField(value: _storage._format, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      try { if let v = _storage._defaultValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._dataSource != .details {
        try visitor.visitSingularEnumField(value: _storage._dataSource, fieldNumber: 5)
      }
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 6)
      }
      if _storage._readOnly != false {
        try visitor.visitSingularBoolField(value: _storage._readOnly, fieldNumber: 7)
      }
      if _storage._multi != false {
        try visitor.visitSingularBoolField(value: _storage._multi, fieldNumber: 8)
      }
      if !_storage._objectTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._objectTypes, fieldNumber: 9)
      }
      if !_storage._selectDict.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._selectDict, fieldNumber: 12)
      }
      if _storage._maxCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxCount, fieldNumber: 13)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 14)
      }
      if _storage._readOnlyRelation != false {
        try visitor.visitSingularBoolField(value: _storage._readOnlyRelation, fieldNumber: 15)
      }
      if _storage._scope != .object {
        try visitor.visitSingularEnumField(value: _storage._scope, fieldNumber: 20)
      }
      if !_storage._creator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creator, fieldNumber: 21)
      }
      if _storage._revision != 0 {
        try visitor.visitSingularInt64Field(value: _storage._revision, fieldNumber: 22)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Relation, rhs: Anytype_Model_Relation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._defaultValue != rhs_storage._defaultValue {return false}
        if _storage._dataSource != rhs_storage._dataSource {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._readOnlyRelation != rhs_storage._readOnlyRelation {return false}
        if _storage._multi != rhs_storage._multi {return false}
        if _storage._objectTypes != rhs_storage._objectTypes {return false}
        if _storage._selectDict != rhs_storage._selectDict {return false}
        if _storage._maxCount != rhs_storage._maxCount {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._revision != rhs_storage._revision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Relation.Scope: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "object"),
    1: .same(proto: "type"),
    2: .same(proto: "setOfTheSameType"),
    3: .same(proto: "objectsOfTheSameType"),
    4: .same(proto: "library"),
  ]
}

extension Anytype_Model_Relation.DataSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "details"),
    1: .same(proto: "derived"),
    2: .same(proto: "account"),
    3: .same(proto: "local"),
  ]
}

extension Anytype_Model_Relation.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Relation.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "text"),
    3: .same(proto: "color"),
    5: .same(proto: "relationKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.color) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 3)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Relation.Option, rhs: Anytype_Model_Relation.Option) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_RelationLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_RelationLink, rhs: Anytype_Model_RelationLink) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Relations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Relations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Relations, rhs: Anytype_Model_Relations) -> Bool {
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_RelationOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_RelationOptions, rhs: Anytype_Model_RelationOptions) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_InternalFlag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalFlag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .editorDeleteEmpty {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_InternalFlag, rhs: Anytype_Model_InternalFlag) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_InternalFlag.Value: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "editorDeleteEmpty"),
    1: .same(proto: "editorSelectType"),
    2: .same(proto: "editorSelectTemplate"),
    3: .same(proto: "collectionDontIndexLinks"),
  ]
}

extension Anytype_Model_ObjectView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootId"),
    2: .same(proto: "blocks"),
    3: .same(proto: "details"),
    4: .same(proto: "type"),
    7: .same(proto: "relations"),
    10: .same(proto: "relationLinks"),
    8: .same(proto: "restrictions"),
    9: .same(proto: "history"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._restrictions) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.relationLinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rootID.isEmpty {
      try visitor.visitSingularStringField(value: self.rootID, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 3)
    }
    if self.type != .accountOld {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 7)
    }
    try { if let v = self._restrictions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.relationLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationLinks, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ObjectView, rhs: Anytype_Model_ObjectView) -> Bool {
    if lhs.rootID != rhs.rootID {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.details != rhs.details {return false}
    if lhs.type != rhs.type {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.relationLinks != rhs.relationLinks {return false}
    if lhs._restrictions != rhs._restrictions {return false}
    if lhs._history != rhs._history {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ObjectView.DetailsSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_ObjectView.protoMessageName + ".DetailsSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "details"),
    3: .same(proto: "subIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.subIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.subIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ObjectView.DetailsSet, rhs: Anytype_Model_ObjectView.DetailsSet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._details != rhs._details {return false}
    if lhs.subIds != rhs.subIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ObjectView.RelationWithValuePerObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_ObjectView.protoMessageName + ".RelationWithValuePerObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ObjectView.RelationWithValuePerObject, rhs: Anytype_Model_ObjectView.RelationWithValuePerObject) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ObjectView.HistorySize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_ObjectView.protoMessageName + ".HistorySize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "undo"),
    2: .same(proto: "redo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.undo) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.redo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.undo != 0 {
      try visitor.visitSingularInt32Field(value: self.undo, fieldNumber: 1)
    }
    if self.redo != 0 {
      try visitor.visitSingularInt32Field(value: self.redo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ObjectView.HistorySize, rhs: Anytype_Model_ObjectView.HistorySize) -> Bool {
    if lhs.undo != rhs.undo {return false}
    if lhs.redo != rhs.redo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ParticipantPermissionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParticipantPermissionChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "perms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.perms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if self.perms != .reader {
      try visitor.visitSingularEnumField(value: self.perms, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ParticipantPermissionChange, rhs: Anytype_Model_ParticipantPermissionChange) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.perms != rhs.perms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anytype_Model_Metadata.Payload.IdentityPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .identity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .identity(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .identity(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Metadata, rhs: Anytype_Model_Metadata) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Metadata.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Metadata.protoMessageName + ".Payload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Metadata.Payload, rhs: Anytype_Model_Metadata.Payload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Metadata.Payload.IdentityPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Metadata.Payload.protoMessageName + ".IdentityPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileSymKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.profileSymKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.profileSymKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileSymKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Metadata.Payload.IdentityPayload, rhs: Anytype_Model_Metadata.Payload.IdentityPayload) -> Bool {
    if lhs.profileSymKey != rhs.profileSymKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "createTime"),
    4: .same(proto: "status"),
    5: .same(proto: "isLocal"),
    6: .same(proto: "import"),
    8: .same(proto: "export"),
    9: .same(proto: "galleryImport"),
    10: .same(proto: "requestToJoin"),
    11: .same(proto: "test"),
    13: .same(proto: "participantRequestApproved"),
    15: .same(proto: "requestToLeave"),
    16: .same(proto: "participantRemove"),
    17: .same(proto: "participantRequestDecline"),
    18: .same(proto: "participantPermissionsChange"),
    7: .same(proto: "space"),
    14: .same(proto: "aclHeadId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLocal) }()
      case 6: try {
        var v: Anytype_Model_Notification.Import?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .import(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .import(v)
        }
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.space) }()
      case 8: try {
        var v: Anytype_Model_Notification.Export?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .export(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .export(v)
        }
      }()
      case 9: try {
        var v: Anytype_Model_Notification.GalleryImport?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .galleryImport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .galleryImport(v)
        }
      }()
      case 10: try {
        var v: Anytype_Model_Notification.RequestToJoin?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .requestToJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .requestToJoin(v)
        }
      }()
      case 11: try {
        var v: Anytype_Model_Notification.Test?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .test(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .test(v)
        }
      }()
      case 13: try {
        var v: Anytype_Model_Notification.ParticipantRequestApproved?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .participantRequestApproved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .participantRequestApproved(v)
        }
      }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.aclHeadID) }()
      case 15: try {
        var v: Anytype_Model_Notification.RequestToLeave?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .requestToLeave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .requestToLeave(v)
        }
      }()
      case 16: try {
        var v: Anytype_Model_Notification.ParticipantRemove?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .participantRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .participantRemove(v)
        }
      }()
      case 17: try {
        var v: Anytype_Model_Notification.ParticipantRequestDecline?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .participantRequestDecline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .participantRequestDecline(v)
        }
      }()
      case 18: try {
        var v: Anytype_Model_Notification.ParticipantPermissionsChange?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .participantPermissionsChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .participantPermissionsChange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 2)
    }
    if self.status != .created {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.isLocal != false {
      try visitor.visitSingularBoolField(value: self.isLocal, fieldNumber: 5)
    }
    try { if case .import(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.space.isEmpty {
      try visitor.visitSingularStringField(value: self.space, fieldNumber: 7)
    }
    switch self.payload {
    case .export?: try {
      guard case .export(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .galleryImport?: try {
      guard case .galleryImport(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .requestToJoin?: try {
      guard case .requestToJoin(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .test?: try {
      guard case .test(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .participantRequestApproved?: try {
      guard case .participantRequestApproved(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    default: break
    }
    if !self.aclHeadID.isEmpty {
      try visitor.visitSingularStringField(value: self.aclHeadID, fieldNumber: 14)
    }
    switch self.payload {
    case .requestToLeave?: try {
      guard case .requestToLeave(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .participantRemove?: try {
      guard case .participantRemove(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .participantRequestDecline?: try {
      guard case .participantRequestDecline(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .participantPermissionsChange?: try {
      guard case .participantPermissionsChange(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification, rhs: Anytype_Model_Notification) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.isLocal != rhs.isLocal {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.space != rhs.space {return false}
    if lhs.aclHeadID != rhs.aclHeadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Created"),
    1: .same(proto: "Shown"),
    2: .same(proto: "Read"),
    3: .same(proto: "Replied"),
  ]
}

extension Anytype_Model_Notification.ActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSE"),
  ]
}

extension Anytype_Model_Notification.Import: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".Import"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processId"),
    2: .same(proto: "errorCode"),
    3: .same(proto: "importType"),
    4: .same(proto: "spaceId"),
    5: .same(proto: "name"),
    6: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.processID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.importType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processID.isEmpty {
      try visitor.visitSingularStringField(value: self.processID, fieldNumber: 1)
    }
    if self.errorCode != .null {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if self.importType != .notion {
      try visitor.visitSingularEnumField(value: self.importType, fieldNumber: 3)
    }
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.Import, rhs: Anytype_Model_Notification.Import) -> Bool {
    if lhs.processID != rhs.processID {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.importType != rhs.importType {return false}
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.Export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".Export"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "errorCode"),
    3: .same(proto: "exportType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.exportType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .null {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if self.exportType != .markdown {
      try visitor.visitSingularEnumField(value: self.exportType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.Export, rhs: Anytype_Model_Notification.Export) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.exportType != rhs.exportType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.Export.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Model_Notification.GalleryImport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".GalleryImport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processId"),
    2: .same(proto: "errorCode"),
    3: .same(proto: "spaceId"),
    4: .same(proto: "name"),
    5: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.processID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processID.isEmpty {
      try visitor.visitSingularStringField(value: self.processID, fieldNumber: 1)
    }
    if self.errorCode != .null {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.GalleryImport, rhs: Anytype_Model_Notification.GalleryImport) -> Bool {
    if lhs.processID != rhs.processID {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.RequestToJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".RequestToJoin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceId"),
    2: .same(proto: "identity"),
    3: .same(proto: "identityName"),
    4: .same(proto: "identityIcon"),
    5: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identityName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identityIcon) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.identityName.isEmpty {
      try visitor.visitSingularStringField(value: self.identityName, fieldNumber: 3)
    }
    if !self.identityIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.identityIcon, fieldNumber: 4)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.RequestToJoin, rhs: Anytype_Model_Notification.RequestToJoin) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.identityName != rhs.identityName {return false}
    if lhs.identityIcon != rhs.identityIcon {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.Test: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".Test"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.Test, rhs: Anytype_Model_Notification.Test) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.ParticipantRequestApproved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".ParticipantRequestApproved"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceId"),
    2: .same(proto: "permissions"),
    5: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.permissions) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    if self.permissions != .reader {
      try visitor.visitSingularEnumField(value: self.permissions, fieldNumber: 2)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.ParticipantRequestApproved, rhs: Anytype_Model_Notification.ParticipantRequestApproved) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.RequestToLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".RequestToLeave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceId"),
    2: .same(proto: "identity"),
    3: .same(proto: "identityName"),
    4: .same(proto: "identityIcon"),
    5: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identityName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identityIcon) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.identityName.isEmpty {
      try visitor.visitSingularStringField(value: self.identityName, fieldNumber: 3)
    }
    if !self.identityIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.identityIcon, fieldNumber: 4)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.RequestToLeave, rhs: Anytype_Model_Notification.RequestToLeave) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.identityName != rhs.identityName {return false}
    if lhs.identityIcon != rhs.identityIcon {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.ParticipantRemove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".ParticipantRemove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "identityName"),
    3: .same(proto: "identityIcon"),
    4: .same(proto: "spaceId"),
    5: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identityName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identityIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.identityName.isEmpty {
      try visitor.visitSingularStringField(value: self.identityName, fieldNumber: 2)
    }
    if !self.identityIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.identityIcon, fieldNumber: 3)
    }
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 4)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.ParticipantRemove, rhs: Anytype_Model_Notification.ParticipantRemove) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.identityName != rhs.identityName {return false}
    if lhs.identityIcon != rhs.identityIcon {return false}
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.ParticipantRequestDecline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".ParticipantRequestDecline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceId"),
    3: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.ParticipantRequestDecline, rhs: Anytype_Model_Notification.ParticipantRequestDecline) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Notification.ParticipantPermissionsChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Notification.protoMessageName + ".ParticipantPermissionsChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spaceId"),
    2: .same(proto: "permissions"),
    3: .same(proto: "spaceName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.permissions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 1)
    }
    if self.permissions != .reader {
      try visitor.visitSingularEnumField(value: self.permissions, fieldNumber: 2)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Notification.ParticipantPermissionsChange, rhs: Anytype_Model_Notification.ParticipantPermissionsChange) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Export"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Export, rhs: Anytype_Model_Export) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Export.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Markdown"),
    1: .same(proto: "Protobuf"),
    2: .same(proto: "JSON"),
    3: .same(proto: "DOT"),
    4: .same(proto: "SVG"),
    5: .same(proto: "GRAPH_JSON"),
  ]
}

extension Anytype_Model_Import: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Import"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Import, rhs: Anytype_Model_Import) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Import.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Notion"),
    1: .same(proto: "Markdown"),
    2: .same(proto: "External"),
    3: .same(proto: "Pb"),
    4: .same(proto: "Html"),
    5: .same(proto: "Txt"),
    6: .same(proto: "Csv"),
  ]
}

extension Anytype_Model_Import.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "INTERNAL_ERROR"),
    5: .same(proto: "NO_OBJECTS_TO_IMPORT"),
    6: .same(proto: "IMPORT_IS_CANCELED"),
    7: .same(proto: "LIMIT_OF_ROWS_OR_RELATIONS_EXCEEDED"),
    8: .same(proto: "FILE_LOAD_ERROR"),
    9: .same(proto: "INSUFFICIENT_PERMISSIONS"),
  ]
}

extension Anytype_Model_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Invite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Invite, rhs: Anytype_Model_Invite) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_InvitePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creatorIdentity"),
    2: .same(proto: "creatorName"),
    3: .same(proto: "inviteKey"),
    4: .same(proto: "spaceId"),
    5: .same(proto: "spaceName"),
    6: .same(proto: "spaceIconCid"),
    7: .same(proto: "spaceIconEncryptionKeys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creatorIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creatorName) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.inviteKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.spaceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.spaceName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.spaceIconCid) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.spaceIconEncryptionKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creatorIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorIdentity, fieldNumber: 1)
    }
    if !self.creatorName.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorName, fieldNumber: 2)
    }
    if !self.inviteKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteKey, fieldNumber: 3)
    }
    if !self.spaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceID, fieldNumber: 4)
    }
    if !self.spaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceName, fieldNumber: 5)
    }
    if !self.spaceIconCid.isEmpty {
      try visitor.visitSingularStringField(value: self.spaceIconCid, fieldNumber: 6)
    }
    if !self.spaceIconEncryptionKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spaceIconEncryptionKeys, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_InvitePayload, rhs: Anytype_Model_InvitePayload) -> Bool {
    if lhs.creatorIdentity != rhs.creatorIdentity {return false}
    if lhs.creatorName != rhs.creatorName {return false}
    if lhs.inviteKey != rhs.inviteKey {return false}
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.spaceName != rhs.spaceName {return false}
    if lhs.spaceIconCid != rhs.spaceIconCid {return false}
    if lhs.spaceIconEncryptionKeys != rhs.spaceIconEncryptionKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_IdentityProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "name"),
    3: .same(proto: "iconCid"),
    4: .same(proto: "iconEncryptionKeys"),
    5: .same(proto: "description"),
    6: .same(proto: "globalName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconCid) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.iconEncryptionKeys) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.globalName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconCid.isEmpty {
      try visitor.visitSingularStringField(value: self.iconCid, fieldNumber: 3)
    }
    if !self.iconEncryptionKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iconEncryptionKeys, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.globalName.isEmpty {
      try visitor.visitSingularStringField(value: self.globalName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_IdentityProfile, rhs: Anytype_Model_IdentityProfile) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconCid != rhs.iconCid {return false}
    if lhs.iconEncryptionKeys != rhs.iconEncryptionKeys {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.globalName != rhs.globalName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_FileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileId"),
    2: .same(proto: "encryptionKeys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.encryptionKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if !self.encryptionKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.encryptionKeys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_FileInfo, rhs: Anytype_Model_FileInfo) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.encryptionKeys != rhs.encryptionKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_FileEncryptionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileEncryptionKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_FileEncryptionKey, rhs: Anytype_Model_FileEncryptionKey) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_ManifestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "author"),
    5: .same(proto: "license"),
    6: .same(proto: "title"),
    7: .same(proto: "description"),
    8: .same(proto: "screenshots"),
    9: .same(proto: "downloadLink"),
    10: .same(proto: "fileSize"),
    11: .same(proto: "categories"),
    12: .same(proto: "language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.license) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.screenshots) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.downloadLink) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.fileSize) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 4)
    }
    if !self.license.isEmpty {
      try visitor.visitSingularStringField(value: self.license, fieldNumber: 5)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if !self.screenshots.isEmpty {
      try visitor.visitRepeatedStringField(value: self.screenshots, fieldNumber: 8)
    }
    if !self.downloadLink.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadLink, fieldNumber: 9)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt32Field(value: self.fileSize, fieldNumber: 10)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 11)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_ManifestInfo, rhs: Anytype_Model_ManifestInfo) -> Bool {
    if lhs.schema != rhs.schema {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.author != rhs.author {return false}
    if lhs.license != rhs.license {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.screenshots != rhs.screenshots {return false}
    if lhs.downloadLink != rhs.downloadLink {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Membership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Membership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tier"),
    2: .same(proto: "status"),
    3: .same(proto: "dateStarted"),
    4: .same(proto: "dateEnds"),
    5: .same(proto: "isAutoRenew"),
    6: .same(proto: "paymentMethod"),
    7: .same(proto: "nsName"),
    8: .same(proto: "nsNameType"),
    9: .same(proto: "userEmail"),
    10: .same(proto: "subscribeToNewsletter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.dateStarted) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.dateEnds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isAutoRenew) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.paymentMethod) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nsName) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.nsNameType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.subscribeToNewsletter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tier != 0 {
      try visitor.visitSingularUInt32Field(value: self.tier, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.dateStarted != 0 {
      try visitor.visitSingularUInt64Field(value: self.dateStarted, fieldNumber: 3)
    }
    if self.dateEnds != 0 {
      try visitor.visitSingularUInt64Field(value: self.dateEnds, fieldNumber: 4)
    }
    if self.isAutoRenew != false {
      try visitor.visitSingularBoolField(value: self.isAutoRenew, fieldNumber: 5)
    }
    if self.paymentMethod != .methodNone {
      try visitor.visitSingularEnumField(value: self.paymentMethod, fieldNumber: 6)
    }
    if !self.nsName.isEmpty {
      try visitor.visitSingularStringField(value: self.nsName, fieldNumber: 7)
    }
    if self.nsNameType != .anyName {
      try visitor.visitSingularEnumField(value: self.nsNameType, fieldNumber: 8)
    }
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 9)
    }
    if self.subscribeToNewsletter != false {
      try visitor.visitSingularBoolField(value: self.subscribeToNewsletter, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Membership, rhs: Anytype_Model_Membership) -> Bool {
    if lhs.tier != rhs.tier {return false}
    if lhs.status != rhs.status {return false}
    if lhs.dateStarted != rhs.dateStarted {return false}
    if lhs.dateEnds != rhs.dateEnds {return false}
    if lhs.isAutoRenew != rhs.isAutoRenew {return false}
    if lhs.paymentMethod != rhs.paymentMethod {return false}
    if lhs.nsName != rhs.nsName {return false}
    if lhs.nsNameType != rhs.nsNameType {return false}
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.subscribeToNewsletter != rhs.subscribeToNewsletter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Membership.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StatusUnknown"),
    1: .same(proto: "StatusPending"),
    2: .same(proto: "StatusActive"),
    3: .same(proto: "StatusPendingRequiresFinalization"),
  ]
}

extension Anytype_Model_Membership.PaymentMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MethodNone"),
    1: .same(proto: "MethodStripe"),
    2: .same(proto: "MethodCrypto"),
    3: .same(proto: "MethodInappApple"),
    4: .same(proto: "MethodInappGoogle"),
  ]
}

extension Anytype_Model_Membership.EmailVerificationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StatusNotVerified"),
    1: .same(proto: "StatusCodeSent"),
    2: .same(proto: "StatusVerified"),
  ]
}

extension Anytype_Model_MembershipTierData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MembershipTierData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "isTest"),
    5: .same(proto: "periodType"),
    6: .same(proto: "periodValue"),
    7: .same(proto: "priceStripeUsdCents"),
    8: .same(proto: "anyNamesCountIncluded"),
    9: .same(proto: "anyNameMinLength"),
    10: .same(proto: "features"),
    11: .same(proto: "colorStr"),
    12: .same(proto: "stripeProductId"),
    13: .same(proto: "stripeManageUrl"),
    15: .same(proto: "iosProductId"),
    16: .same(proto: "iosManageUrl"),
    17: .same(proto: "androidProductId"),
    18: .same(proto: "androidManageUrl"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _name: String = String()
    var _description_p: String = String()
    var _isTest: Bool = false
    var _periodType: Anytype_Model_MembershipTierData.PeriodType = .unknown
    var _periodValue: UInt32 = 0
    var _priceStripeUsdCents: UInt32 = 0
    var _anyNamesCountIncluded: UInt32 = 0
    var _anyNameMinLength: UInt32 = 0
    var _features: [String] = []
    var _colorStr: String = String()
    var _stripeProductID: String = String()
    var _stripeManageURL: String = String()
    var _iosProductID: String = String()
    var _iosManageURL: String = String()
    var _androidProductID: String = String()
    var _androidManageURL: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _description_p = source._description_p
      _isTest = source._isTest
      _periodType = source._periodType
      _periodValue = source._periodValue
      _priceStripeUsdCents = source._priceStripeUsdCents
      _anyNamesCountIncluded = source._anyNamesCountIncluded
      _anyNameMinLength = source._anyNameMinLength
      _features = source._features
      _colorStr = source._colorStr
      _stripeProductID = source._stripeProductID
      _stripeManageURL = source._stripeManageURL
      _iosProductID = source._iosProductID
      _iosManageURL = source._iosManageURL
      _androidProductID = source._androidProductID
      _androidManageURL = source._androidManageURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isTest) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._periodType) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._periodValue) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._priceStripeUsdCents) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._anyNamesCountIncluded) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._anyNameMinLength) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._features) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._colorStr) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._stripeProductID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._stripeManageURL) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._iosProductID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._iosManageURL) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._androidProductID) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._androidManageURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._isTest != false {
        try visitor.visitSingularBoolField(value: _storage._isTest, fieldNumber: 4)
      }
      if _storage._periodType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._periodType, fieldNumber: 5)
      }
      if _storage._periodValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._periodValue, fieldNumber: 6)
      }
      if _storage._priceStripeUsdCents != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._priceStripeUsdCents, fieldNumber: 7)
      }
      if _storage._anyNamesCountIncluded != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._anyNamesCountIncluded, fieldNumber: 8)
      }
      if _storage._anyNameMinLength != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._anyNameMinLength, fieldNumber: 9)
      }
      if !_storage._features.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._features, fieldNumber: 10)
      }
      if !_storage._colorStr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._colorStr, fieldNumber: 11)
      }
      if !_storage._stripeProductID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stripeProductID, fieldNumber: 12)
      }
      if !_storage._stripeManageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stripeManageURL, fieldNumber: 13)
      }
      if !_storage._iosProductID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iosProductID, fieldNumber: 15)
      }
      if !_storage._iosManageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iosManageURL, fieldNumber: 16)
      }
      if !_storage._androidProductID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._androidProductID, fieldNumber: 17)
      }
      if !_storage._androidManageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._androidManageURL, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_MembershipTierData, rhs: Anytype_Model_MembershipTierData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._isTest != rhs_storage._isTest {return false}
        if _storage._periodType != rhs_storage._periodType {return false}
        if _storage._periodValue != rhs_storage._periodValue {return false}
        if _storage._priceStripeUsdCents != rhs_storage._priceStripeUsdCents {return false}
        if _storage._anyNamesCountIncluded != rhs_storage._anyNamesCountIncluded {return false}
        if _storage._anyNameMinLength != rhs_storage._anyNameMinLength {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._colorStr != rhs_storage._colorStr {return false}
        if _storage._stripeProductID != rhs_storage._stripeProductID {return false}
        if _storage._stripeManageURL != rhs_storage._stripeManageURL {return false}
        if _storage._iosProductID != rhs_storage._iosProductID {return false}
        if _storage._iosManageURL != rhs_storage._iosManageURL {return false}
        if _storage._androidProductID != rhs_storage._androidProductID {return false}
        if _storage._androidManageURL != rhs_storage._androidManageURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_MembershipTierData.PeriodType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PeriodTypeUnknown"),
    1: .same(proto: "PeriodTypeUnlimited"),
    2: .same(proto: "PeriodTypeDays"),
    3: .same(proto: "PeriodTypeWeeks"),
    4: .same(proto: "PeriodTypeMonths"),
    5: .same(proto: "PeriodTypeYears"),
  ]
}
